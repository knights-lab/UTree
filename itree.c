#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/types.h> 
//#include <unistd.h>
#include <fcntl.h>
#include <math.h>
#define _LARGEFILE64_SOURCE
off_t lseek(int fd, off_t offset, int whence); 

/*  RadixalTriecrobium. A tree utility for k-mer manipulation.
///////////////////// UTILITY FUNCTIONS //////////////////////
Add a (numerical) word and its ix to a tree. Be sure to manage
manually-added indices with caution. 
	void KT_addWordIx(KTree *ktree, WTYPE word, IXTYPE ix)

Sync the tree manually. For advanced use. 
	void KT_sync(KTree *ktree);

Return the index of a (numerical) word, returns BAD_IX if not found
	IXTYPE KT_findIx(KTree *ktree, WTYPE word);

Return the index and counts of a (numerical) word. Pass a size_t ref
	IXTYPE KT_findIxCount(KTree *ktree, WTYPE word, size_t *count); 

Convert a (string) k-mer into its numeric representation (too short: pad
with A's at end. Too long: gets last possible. 
	WTYPE KT_word2num(char *str);

Convert a numeric word into its string representation
	char * KT_num2word(WTYPE word);

Parses a linearized, paired-line fasta file with string samples,
truncating sample name by newline, null, space, or underscore.
Returns how many sequences successfully parsed.
	size_t KT_parseSampFasta(KTree *ktree, char* filename);
	
As above, but doesn't parse every single overlap-- just size of kmer.
Speed parameter controls stringency in filling gaps between non-unique hits.
	size_t KT_parseSampFastaSparse(KTree *ktree, char* filename, int speed);

As above, but where the sample names are the numerical indices.
	size_t KT_parseIxFasta(KTree *ktree, char* filename);

///////////////////////// LOAD/SAVE ////////////////////////////
Create an empty tree object. Necessary for calling other functions
	KTree * KT_createTree(int numThreads);

Read samples from newline delimited file. Sample order becomes ix.
	int KT_readSamples(KTree *ktree, char *filename);

Writes auto-generated indices in tree order to file. Can be
used with KT_readSamples to populate a tree just read in
	int KT_writeSamples(KTree *ktree, char *filename);

Reads previously-output binary tree into new tree object. Pair
with KT_readSamples for full auto-indexed tree reconstruction.
	KTree * KT_readTreeBinary(char* filename, int threads);

Write tree in binary format. Does not include ix->sample mapping
if indices were autogenerated, so pair with KT_writeSamples.
	int KT_writeTreeBinary(KTree *ktree, char* filename);
	
Writes text format of the tree in the following format:
word (string) [tab] word (numeric) [tab] frequency [tab] ix [NL]
	int KT_writeTreeTxt(KTree *ktree, char* filename);
	int KT_writeFullTreeBinary(KTree *ktree, char* filename);

Same as above, but includes non-unique nodes
	int KT_writeFullTreeTxt(KTree *ktree, char* filename)
	
Useful stats in tree object: (sync tree before using)
	size_t numInserted, totalCount; // total number of nodes and k-mers
	IXTYPE sampIX; // the current max ix. New ix will be this + 1
	char **SampStrings; // array of all samples in inserted order
	
The Load/save functions return 0 on failure. 
*/

#ifdef _OPENMP
#include <omp.h>
#endif
#ifdef USE_QSORT
#include "qsort.h"
#endif
#ifndef IXTYPE
	#define IXTYPE uint16_t
#endif
#ifndef CNTTYPE
	#define CNTTYPE uint32_t
#endif
#ifndef PACKSIZE
	#define PACKSIZE 32
#endif
// Hash of trees
#ifndef PFBITS
	#define PFBITS 16
#endif
#if PFBITS>16
	#define PFTYPE uint32_t
#else
	#define PFTYPE uint16_t
#endif
#define KHASH_SIZE (WTYPE)(1 << PFBITS)
#define BALBUFSZ 65536
#if PACKSIZE==64
	#define WTYPE __uint128_t
	#define STYPE WTYPE
	#define SEQPACKS 1024
	#define RSHFT 126
#elif PACKSIZE==32
	#define WTYPE uint64_t
	#define STYPE WTYPE
	#define SEQPACKS 2048
	#define RSHFT 62
#elif PACKSIZE==16
	#define WTYPE uint32_t
	#define STYPE uint16_t
	#define SEQPACKS 4096
	#define RSHFT 30
#elif PACKSIZE==8
	#define WTYPE uint16_t
	#define STYPE uint8_t
	#define SEQPACKS 8192
	#define RSHFT 14
#elif PACKSIZE==4
	#define WTYPE uint8_t
	#define STYPE WTYPE
	#define SEQPACKS 16384
	#define RSHFT 6
#endif
const char* TYPEARR[17] = {"NA","uint8_t", "uint16_t","NA","uint32_t",
"NA","NA","NA","uint64_t","NA","NA","NA","NA","NA","NA","NA","__uint128_t"};

typedef struct KMerX KMerX;
struct 
//#if PACKSIZE<64
/* __attribute__ ((__packed__))  */
//#endif
KMerX {
	WTYPE word;
	CNTTYPE count;
	IXTYPE ix;
	KMerX *left, *right;
	//uint8_t flag;
};

typedef struct KMerY KMerY;
struct 
/* __attribute__ ((__packed__))  */
KMerY {
	STYPE word;
#ifndef NO_COUNT
	CNTTYPE count;
#endif
	IXTYPE ix;
	KMerY *left, *right;
};

typedef struct SampX SampX;
struct /* __attribute__ ((__packed__))  */SampX {
	char *name;
	IXTYPE ix;
	SampX *left, *right;
};

//KMerY *BALBUF[BALBUFSZ];

// Transformation of DNA to numeral
WTYPE *C2Xb; _Bool INIT_K = 0;
char *X2C = "ACGTNNNNNNNNNNNNNNNN";
char *X2C_RC = "TGCANNNNNNNNNNNNNNNN";

// Explicit thread memory management
KMerX ***KBANK = 0; 
size_t KBANK_MAXK = 10000, KBANK_INITBINS = 100, 
	FIRETHRES = 1000000, BAL_THRES = 255;
size_t *KBANK_BIN = 0, *KBANK_BINCNT = 0, *KBANK_IX = 0;

KMerY ***UBANK = 0; 
size_t UBANK_MAXK = 10000, UBANK_INITBINS = 100, UBAL_THRES=7; 
size_t *UBANK_BIN = 0, *UBANK_BINCNT = 0, *UBANK_IX = 0;


char WORDTEMP[PACKSIZE+1] = {0};
IXTYPE BAD_IX = (IXTYPE)-1;
IXTYPE EMPTY_IX = (IXTYPE)-2;
KMerY BAD_NODE; 

// initialize DNA converters
void initConverter() {
	if (!INIT_K) {
	C2Xb = malloc(128*sizeof(WTYPE));
	for (int i = 0; i < 128; ++i) C2Xb[i] = 255;
	C2Xb['a'] = 0; C2Xb['A'] = 0; 
	C2Xb['c'] = 1; C2Xb['C'] = 1; 
	C2Xb['g'] = 2; C2Xb['G'] = 2;
	C2Xb['t'] = 3; C2Xb['T'] = 3;
	#ifdef NO_COUNT
		BAD_NODE = (KMerY){0,BAD_IX,0,0};
	#else
		BAD_NODE = (KMerY){0,0,BAD_IX,0,0};
	#endif
	INIT_K = 1;
	}
}

typedef struct /* __attribute__ ((__packed__))  */{
	WTYPE word;
#ifndef NO_COUNT
	CNTTYPE count;
#endif
	IXTYPE ix;
} KCache;

typedef struct /* __attribute__ ((__packed__))  */{
	WTYPE word;
	IXTYPE ix;
} WordIxPair;

typedef struct {
	size_t *BalanceThreshes, *TotalCounts, *NumsInserted;
	WTYPE *Clumps;
	IXTYPE *IXs;
	KMerX **Roots;
	size_t queuedClumps, numInserted, totalCount;
	uint64_t *SampCnts;
	int numThreads, synced;
	SampX *Samps;
	IXTYPE sampIX;
	char **SampStrings;
	size_t sampStringSz;
} KTree;

typedef struct {
	KMerY **Roots; // prefix cache
	size_t *BalanceThreshes, *NumsInserted, *TotalCounts;  // parallel to prefix cache
	size_t numInserted, totalCount; // global
	int numThreads; // only for searching
	SampX *Samps; // sample tree
	IXTYPE sampIX; // current IX (num of samples currently in)
	char **SampStrings; // array of sample names
	uint64_t *SampCnts; // array of sample counts
	uint8_t *semicolons;	
	size_t sampStringSz; // size of above array
	size_t queuedClumps;
	WordIxPair *Pairs; // Word and IX in here
	void *BinIx;
	char *Dump;
	
} UTree;

/* typedef struct {
	char **SampStrings;
	uint64_t *SampCnts;
	uint8_t *semicolons;
	size_t sampStringSz;
	WordIxPair *Pairs; // Word and IX in here
} */

inline char * num2word(WTYPE num, char * word) {
	int go = 0; for (; go < PACKSIZE; go++) {
		WTYPE temp = (WTYPE)num >> RSHFT;
		word[go] = X2C[temp];
		num <<= 2;
	}
	return word;
}

inline char * num2wordRC(WTYPE num, char * word) {
	int go = PACKSIZE-1; for (; go > -1; go--) {
		WTYPE temp = (WTYPE)num >> RSHFT;
		word[go] = X2C_RC[temp];
		num <<= 2;
	}
	return word;
}

inline char * decodeStringX(WTYPE * Seq, uint16_t length, char *word, char *newString) {
	unsigned clumps = length/PACKSIZE;
	if (PACKSIZE*clumps < length) ++clumps;
	int z = 0; for (; z < clumps-1; z++) 
		num2word(Seq[z],newString + z*PACKSIZE);
	num2word(Seq[clumps-1],newString+z*PACKSIZE);
	newString[length] = 0;
	return newString;
}

inline char * decodeStringXRC(WTYPE * Seq, uint16_t length, char *word, char *newString) {
	newString[length] = 0;
	unsigned clumps = length/PACKSIZE;
	if (PACKSIZE*clumps < length) ++clumps;
	int z = clumps-2; for (; z > -1; z--) 
		num2wordRC(Seq[z],newString + length - (z+1) *PACKSIZE);
	num2wordRC(Seq[clumps-1],word);
	register int fold = length % PACKSIZE; if (!fold) fold = PACKSIZE;
	memcpy(newString,word+PACKSIZE-fold, fold); 
	return newString;
}

inline KMerX * xalloc(int thread, WTYPE word, IXTYPE ix) { // KBANK,KBANK_INITBINS,KBANK_MAXK,KBANK_BIN,KBANK_IX
	#ifdef MINRAM
		#define BUMP_MEM 1.1
	#else
		#define BUMP_MEM 1.25
	#endif
	KMerX *Kptr = KBANK[thread][KBANK_BIN[thread]] + KBANK_IX[thread];
	*Kptr = (KMerX){word,1,ix,0,0};
	if (++KBANK_IX[thread] == KBANK_MAXK) { // reset the ix, increment bin
		KBANK_IX[thread] = 0;
		if (++KBANK_BIN[thread] == KBANK_BINCNT[thread]) { // resize bin array
			KBANK[thread] = realloc(KBANK[thread],
				sizeof(*KBANK[thread])*(KBANK_BINCNT[thread]*=BUMP_MEM));
			if (!KBANK[thread]) { puts("ERROR: xalloc 1"); exit(3); }
			for (size_t x=KBANK_BINCNT[thread]/BUMP_MEM; x<KBANK_BINCNT[thread]; ++x) {
				KBANK[thread][x] = malloc(KBANK_MAXK*sizeof(*KBANK[thread][x]));
				if (!KBANK[thread][x]) { puts("ERROR: xalloc 2"); exit(3); }
			}
		}
	}
	return Kptr;
}

inline KMerY * u_xalloc(STYPE word, IXTYPE ix) { // KBANK,KBANK_INITBINS,KBANK_MAXK,KBANK_BIN,KBANK_IX
	#ifdef MINRAM
		#define BUMP_MEM 1.1
	#else
		#define BUMP_MEM 1.25
	#endif 
	KMerY *Kptr = UBANK[0][UBANK_BIN[0]] + UBANK_IX[0];
	#ifdef NO_COUNT
		*Kptr = (KMerY){word,ix,0,0};
	#else
		*Kptr = (KMerY){word,1,ix,0,0};
	#endif
	if (++UBANK_IX[0] == UBANK_MAXK) { // reset the ix, increment bin
		UBANK_IX[0] = 0;
		if (++UBANK_BIN[0] == UBANK_BINCNT[0]) { // resize bin array
			UBANK[0] = realloc(UBANK[0],
				sizeof(*UBANK[0])*(UBANK_BINCNT[0]*=BUMP_MEM));
			if (!UBANK[0]) { puts("ERROR: xalloc 1"); exit(3); }
			for (size_t x=UBANK_BINCNT[0]/BUMP_MEM; x<UBANK_BINCNT[0]; ++x) {
				UBANK[0][x] = malloc(UBANK_MAXK*sizeof(*UBANK[0][x]));
				if (!UBANK[0][x]) { puts("ERROR: xalloc 2"); exit(3); }
			}
		}
	}
	return Kptr;
}

void rexalloc(int threads) {
	for (int i = 0; i < threads; ++i) {
		KBANK[i] = realloc(KBANK[i],sizeof(*KBANK[i])*KBANK_BIN[i]);
		KBANK[i][KBANK_BIN[i]] = realloc(KBANK[i][KBANK_BIN[i]],
			sizeof(*KBANK[i][KBANK_BIN[i]]) * KBANK_IX[i]);
	}
}

#define EXPAND_SAMPARRAYS() \
if (++ktree->sampIX >= ktree->sampStringSz) { \
	ktree->SampStrings = realloc(ktree->SampStrings, \
		sizeof(*ktree->SampStrings)*(ktree->sampStringSz *=2)); \
	DO_SAMPCNTS() \
}
#define EXPAND_SAMPCNTS() \
ktree->SampCnts = realloc(ktree->SampCnts, \
	sizeof(*ktree->SampCnts)*(ktree->sampStringSz)); \
for (long i=ktree->sampStringSz/2; i < ktree->sampStringSz; ++i) \
	ktree->SampCnts[i] = 0;

#define ADDSAMP() \
SampX *tree = ktree->Samps; \
int cmp = strcmp(str,tree->name); \
do { \
	if (cmp > 0) {\
		if (!tree->right) { \
			tree->right = malloc(sizeof(*tree->right)); \
			tree->right->name = malloc(strlen(str)+1); \
			strcpy(tree->right->name,str); \
			tree->right->right = 0, tree->right->left = 0; \
			EXPAND_SAMPARRAYS() \
			ktree->SampStrings[ktree->sampIX] = tree->right->name; \
			/* ADD_SAMPS() */ \
			return tree->right->ix = ktree->sampIX; \
		} \
		tree = tree->right; \
	} \
	else if (cmp < 0) { \
		if (!tree->left) { \
			tree->left = malloc(sizeof(*tree->left)); \
			tree->left->name = malloc(strlen(str)+1); \
			strcpy(tree->left->name,str); \
			tree->left->right = 0, tree->left->left = 0; \
			EXPAND_SAMPARRAYS() \
			ktree->SampStrings[ktree->sampIX] = tree->left->name; \
			/* ADD_SAMPS() */ \
			return tree->left->ix = ktree->sampIX; \
		} \
		tree = tree->left; \
	} \
} while (cmp=strcmp(str,tree->name)); \
return tree->ix;

#define DO_SAMPCNTS() {}
//#define ADD_SAMPS() {}
IXTYPE addSample(KTree *ktree, char *str) { ADDSAMP() }
inline IXTYPE addSampleUd(UTree *ktree, char *str) { ADDSAMP() }
inline IXTYPE addSampleU(UTree *ktree, char *str) {
	if (!ktree->Samps) {
		ktree->Samps = malloc(sizeof(*ktree->Samps));
		char *strT = malloc(strlen(str+1));
		strcpy(strT,str);
		*ktree->Samps = (SampX){strT,0,0,0};
		ktree->SampStrings = malloc(sizeof(*ktree->SampStrings)*ktree->sampStringSz);
		//ktree->SampCnts = calloc(ktree->sampStringSz,sizeof(*ktree->SampCnts));
		*ktree->SampStrings = strT;
		return 0;
	}
	ADDSAMP()
}
#undef DO_SAMPCNTS
//#undef ADD_SAMPS
#define DO_SAMPCNTS EXPAND_SAMPCNTS
//#define ADD_SAMPS() ktree->SampCnts[ktree->sampIX] = (uint64_t)atol(;
inline IXTYPE addSampleUdX(UTree *ktree, char *str) { ADDSAMP() }


// returns whether new node was created; a counter
inline int xeTree(KMerX *tree, WTYPE word, IXTYPE ix, int T) { 
	do {
		if (word > tree->word) { // go right
			if (!tree->right) {
				tree->right = xalloc(T,word,ix);
				return 1;
			}
			tree = tree->right; 
		}
		else if (word < tree->word) { // go left
			if (!tree->left) {
				tree->left = xalloc(T,word,ix);
				return 1;
			}
			tree = tree->left;
		}
	} while (word != tree->word);
#if CNTTYPE==uint16_t || CNTTYPE==uint8_t
	if (tree->count < (CNTTYPE)-1)
#endif
		++tree->count;
	if (ix != tree->ix) tree->ix = BAD_IX;
	return 0;
}

// returns node status: -1 = just went bad, 0 = no change, 1 = just created
inline int xeTreeU(KMerY *tree, WTYPE word, IXTYPE ix) { 
	do {
		if (word > tree->word) { // go right
			if (!tree->right) {
				tree->right = u_xalloc(word,ix);
				return 1;
			}
			tree = tree->right; 
		}
		else if (word < tree->word) { // go left
			if (!tree->left) {
				tree->left = u_xalloc(word,ix);
				return 1;
			}
			tree = tree->left;
		}
	} while (word != tree->word);
//#if CNTTYPE==uint16_t || CNTTYPE==uint8_t
#ifndef NO_COUNT
	if (tree->count < (CNTTYPE)-1)
//#endif
		++tree->count;
#endif
	
	if (ix != tree->ix) { 
		if (tree->ix == BAD_IX) return 0; // already bad
		tree->ix = BAD_IX; 
		return -1; 
	}
	return 0;
}
// returns node status as above; 2+ = converted to new ix
inline long xeTreeU_GG(KMerY *tree, WTYPE word, IXTYPE ix, UTree *ut) { 
	do {
		if (word > tree->word) { // go right
			if (!tree->right) {
				tree->right = u_xalloc(word,ix);
				return 1;
			}
			tree = tree->right; 
		}
		else if (word < tree->word) { // go left
			if (!tree->left) {
				tree->left = u_xalloc(word,ix);
				return 1;
			}
			tree = tree->left;
		}
	} while (word != tree->word);
//#if CNTTYPE==uint16_t || CNTTYPE==uint8_t
#ifndef NO_COUNT
	if (tree->count < (CNTTYPE)-1)
//#endif
		++tree->count;
#endif
	//if (tree->ix != BAD_IX && tree-ix != ix) {
	if (ix != tree->ix) {
		//tree->ix = BAD_IX;
		if (tree->ix >= EMPTY_IX) return 0; // already bad
		char *old = ut->SampStrings[tree->ix], *oldOrig = old;
		char *new = ut->SampStrings[ix];
		
		unsigned numP = 0, ixP = 0;
		while (*++old == *++new) 
			if (*old == ';') ++numP, ixP = old - oldOrig;
		
		char buffer[10000] = {0};
		strcpy(buffer,oldOrig);
		//exit(3);
		if (numP < 2) { tree->ix = BAD_IX; return -1; }
		//printf("old = %s\nnew = %s\n",oldOrig,ut->SampStrings[ix]);
		//printf("--> Conserved num semis = %u, position = %u\n",numP, ixP);
		if (numP == 0) // kingdom diverged
			++numP, strcpy(buffer,"k__; "), ixP = 2; 
		if (numP == 1)
			++numP, strcpy(buffer + ixP + 2,"p__; "), ixP += 5;
		if (numP == 2)
			++numP, strcpy(buffer + ixP + 2,"c__; "), ixP += 5;
		if (numP == 3)
			++numP, strcpy(buffer + ixP + 2,"o__; "), ixP += 5;
		if (numP == 4)
			++numP, strcpy(buffer + ixP + 2,"f__; "), ixP += 5;
		if (numP == 5)
			++numP, strcpy(buffer + ixP + 2,"g__; "), ixP += 5;
		if (numP == 6) // species diverged
			strcpy(buffer + ixP + 2,"s__");
		//printf("--> Interpolated: %s\n",buffer);
		IXTYPE new_ix = addSampleUd(ut,buffer);
		
		//printf("--> New IX = %u [old=%u]\n",new_ix,tree->ix);
		tree->ix = new_ix;
		//exit(3);
		return 2+(long)new_ix;
	}
	return 0;
}

#define RETREE() \
for (;;) { \
	if (node->word > tree->word) { \
		if (!tree->right) { \
			node->left = 0; node->right = 0; \
			tree->right = node; \
			return; \
		} \
		tree = tree->right; \
	} \
	else { \
		if (!tree->left) { \
			node->left = 0; node->right = 0; \
			tree->left = node; \
			return; \
		} \
		tree = tree->left; \
	} \
}

// for repopulating an existing tree
void reTree(KMerX *tree, KMerX *node) { 
	RETREE()
}
void reTreeU(KMerY *tree, KMerY *node) { 
	RETREE()
}

// for merging existing trees (returns if new node added)
int meNode(KMerX *tree, KMerX *node) { 
	do {
		if (node->word > tree->word) { // go right
			if (!tree->right) {
				node->left = 0; node->right = 0;
				tree->right = node;
				return 1; // node->count;
			}
			tree = tree->right; 
		}
		else if (node->word < tree->word) { // go left
			if (!tree->left) {
				node->left = 0; node->right = 0;
				tree->left = node;
				return 1; // node->count;
			}
			tree = tree->left;
		}
	} while (node->word != tree->word);
	tree->count += node->count;
	if (tree->ix != node->ix) tree->ix = BAD_IX;
	return 0;
}

// find in tree
size_t fiTree(KMerX *tree, WTYPE word) {
	do {
		if (word > tree->word) { // go right
			if (!tree->right) return 0;
			tree = tree->right; 
		}
		else if (word < tree->word) { // go left
			if (!tree->left) return 0;
			tree = tree->left;
		}
	} while (word != tree->word);
	return tree->count;
}
// find in tree (return IX)
#define IXTREE() {\
	do { \
		if (word > tree->word) { \
			if (!tree->right) return BAD_IX; \
			tree = tree->right;  \
		} \
		else if (word < tree->word) { \
			if (!tree->left) return BAD_IX; \
			tree = tree->left; \
		} \
	} while (word != tree->word); \
	return tree->ix; \
}
inline IXTYPE ixTree(KMerX *tree, WTYPE word) IXTREE()
inline IXTYPE ixTreeU(KMerY *tree, STYPE word) IXTREE()
inline KMerY *getNodeU(UTree *utree, WTYPE wordO) {
	KMerY *tree = utree->Roots[wordO >> ((PACKSIZE << 1) - PFBITS)];
	STYPE word = (wordO << PFBITS) >> PFBITS;
	do { 
		if (word > tree->word) { 
			if (!tree->right) return &BAD_NODE; 
			tree = tree->right;  
		} 
		else if (word < tree->word) { 
			if (!tree->left) return &BAD_NODE; 
			tree = tree->left; 
		} 
	} while (word != tree->word); 
	return tree; 
}

// find in tree (return IX, update count)
IXTYPE ixCntTree(KMerX *tree, WTYPE word, size_t *N) {
	do {
		if (word > tree->word) { // go right
			if (!tree->right) { *N=0; return BAD_IX; }
			tree = tree->right; 
		}
		else if (word < tree->word) { // go left
			if (!tree->left) { *N=0; return BAD_IX; }
			tree = tree->left;
		}
	} while (word != tree->word);
	*N=tree->count; return tree->ix;
}

// Modify tree and set sparsity pointer based on whether
// a k-mer conflicts with one already in the tree.
#ifndef NO_COUNT
	#define UPCOUNT() if (tree->count < (CNTTYPE)-1) ++tree->count;
#else
	#define UPCOUNT() {}
#endif
#define PARAPLUIE() \
	do { \
		if (word > tree->word) { \
			if (!tree->right) { \
				tree->right = MEMALLOC(0,word,ix); \
				++ktree->TotalCounts[prefix]; \
				++ktree->NumsInserted[prefix]; \
				return z/denom; \
			} \
			tree = tree->right; \
		} \
		else if (word < tree->word) { \
			if (!tree->left) { \
				tree->left = MEMALLOC(0,word,ix); \
				++ktree->TotalCounts[prefix]; \
				++ktree->NumsInserted[prefix]; \
				return z/denom; \
			} \
			tree = tree->left; \
		} \
	} while (word != tree->word); \
	if (ix == tree->ix) { \
		/* if (tree->count < (CNTTYPE)-1) ++tree->count; \
		++ktree->TotalCounts[prefix]; */ \
		return 0; \
	} \
	tree->ix = BAD_IX; \
	UPCOUNT() \
	++ktree->TotalCounts[prefix]; \
	return z/denom; /*2*z/(denom+1); */

int parapluie(KTree *ktree, WTYPE word, IXTYPE ix, unsigned z, unsigned denom) {
	KMerX *tree = *ktree->Roots, *root = tree;
	int prefix = 0;
	#define MEMALLOC(th,wd,i) xalloc(th,wd,i)
	PARAPLUIE()
	#undef MEMALLOC
}
//#if CNTTYPE==uint16_t || CNTTYPE==uint8_t
inline int parapluieU(UTree *ktree, WTYPE wordO, IXTYPE ix) {
	int z = 1, denom = 1;
	PFTYPE prefix = wordO >> ((PACKSIZE << 1) - PFBITS);
	KMerY *tree = ktree->Roots[prefix];
	STYPE word = (wordO << PFBITS) >> PFBITS;
	if (tree->ix == EMPTY_IX) {
		#ifdef NO_COUNT
		*tree = (KMerY){word,ix,0,0};
		#else
		*tree = (KMerY){word,1,ix,0,0};
		#endif
		ktree->NumsInserted[prefix] = 1;
		ktree->TotalCounts[prefix] = 1;
		return z/denom;
	}
	#define MEMALLOC(th,wd,i) u_xalloc(wd,i)
	PARAPLUIE()
	#undef MEMALLOC
}
//count

// Search and report if word made bad
#define UMBRELLA() { \
	do { \
		if (word > tree->word) { \
			if (!tree->right) return 0; \
			tree = tree->right; \
		} \
		else if (word < tree->word) { \
			if (!tree->left) return 0; \
			tree = tree->left; \
		} \
	} while (word != tree->word); \
	if (tree->ix == BAD_IX) return 0; \
	if (ix != tree->ix) UPDATE_IX() \
	UMBRELLA_MODIFY() \
	return 0; \
}
#define UPDATE_IX_REG() {tree->ix = BAD_IX; return 1;}
#define UPDATE_IX_GG() { \
	if (tree->ix >= EMPTY_IX) return 0; \
	char *old = ut->SampStrings[tree->ix], *oldOrig = old; \
	char *new = ut->SampStrings[ix]; \
	\
	unsigned numP = 0, ixP = 0; \
	while (*++old == *++new) \
		if (*old == ';') ++numP, ixP = old - oldOrig; \
	\
	char buffer[10000] = {0}; \
	strcpy(buffer,oldOrig); \
	if (numP < 2) { tree->ix = BAD_IX; return 1; } \
	if (numP == 0) \
		++numP, strcpy(buffer,"k__; "), ixP = 2; \
	if (numP == 1) \
		++numP, strcpy(buffer + ixP + 2,"p__; "), ixP += 5; \
	if (numP == 2) \
		++numP, strcpy(buffer + ixP + 2,"c__; "), ixP += 5; \
	if (numP == 3) \
		++numP, strcpy(buffer + ixP + 2,"o__; "), ixP += 5; \
	if (numP == 4) \
		++numP, strcpy(buffer + ixP + 2,"f__; "), ixP += 5; \
	if (numP == 5) \
		++numP, strcpy(buffer + ixP + 2,"g__; "), ixP += 5; \
	if (numP == 6) \
		strcpy(buffer + ixP + 2,"s__"); \
	IXTYPE new_ix = addSampleUd(ut,buffer); \
	tree->ix = new_ix; \
	return 0; \
}

#define UPDATE_IX UPDATE_IX_REG
#define UMBRELLA_MODIFY() {}
inline size_t umbrella(KMerX *tree, WTYPE word, IXTYPE ix) UMBRELLA() 
inline size_t umbrellaU(KMerY *tree, STYPE word, IXTYPE ix) UMBRELLA() 
#undef UPDATE_IX
#define UPDATE_IX UPDATE_IX_GG
inline size_t umbrellaU_GG(KMerY *tree, STYPE word, IXTYPE ix, UTree *ut) UMBRELLA()
#undef UPDATE_IX
#undef UMBRELLA_MODIFY
#ifdef NO_COUNT
#define UMBRELLA_MODIFY() {}
#else
#define UMBRELLA_MODIFY() if (tree->count < (CNTTYPE)-1) ++tree->count; 
#endif
#define UPDATE_IX UPDATE_IX_REG
inline size_t umbrellaUx(KMerY *tree, STYPE word, IXTYPE ix) UMBRELLA() 
#undef UMBRELLA_MODIFY

void KT_simpleBalancePurge(KTree *ktree);
size_t PRUNED = 0;
void checkUmbrella(KTree *ktree) {
	size_t length = ktree->queuedClumps;
	ktree->queuedClumps = 0;
	KMerX *root = *ktree->Roots;
	WTYPE *Words = ktree->Clumps;
	IXTYPE *IXs = ktree->IXs;
	//size_t pruned = 0;
	#pragma omp parallel for \
		schedule(dynamic,1000) \
		shared(root,Words,IXs) \
		reduction(+:PRUNED) 
	for (size_t i = 0; i < length; ++i) {
		PRUNED += umbrella(root, Words[i], IXs[i]);
	}
	//PRUNED += pruned;
	//printf("Number pruned from this balance: %llu / %llu (%f)\n",
	//	PRUNED,ktree->numInserted, (double)PRUNED/ktree->numInserted);
	if ((double)PRUNED/ktree->numInserted > .15) {
		PRUNED = 0;
		printf("Pruning tree...\n");
		KT_simpleBalancePurge(ktree);
	}
}
void checkUmbrella_noBal(KTree *ktree) {
	size_t length = ktree->queuedClumps;
	ktree->queuedClumps = 0;
	KMerX *root = *ktree->Roots;
	WTYPE *Words = ktree->Clumps;
	IXTYPE *IXs = ktree->IXs;
	//size_t pruned = 0;
	#pragma omp parallel for \
		schedule(dynamic,1000) \
		shared(root,Words,IXs) \
		reduction(+:PRUNED)
	for (size_t i = 0; i < length; ++i) {
		PRUNED += umbrella(root, Words[i], IXs[i]);
	}
}
#define CHECK_UMBRELLA() { \
size_t length = utree->queuedClumps; \
	utree->queuedClumps = 0; \
	WordIxPair *Pairs = utree->Pairs; \
	_Pragma("omp parallel for schedule(dynamic,1000) \
		shared(utree,Pairs)") \
	for (size_t i = 0; i < length; ++i) { \
		WTYPE word = Pairs[i].word; \
		UMB_FUNC(utree->Roots[word >> ((PACKSIZE << 1) - \
			PFBITS)], (word << PFBITS) >> PFBITS, Pairs[i].ix); \
	} \
}
#define UMB_FUNC umbrellaU
void checkUmbrellaU(UTree *utree) CHECK_UMBRELLA()
#undef UMB_FUNC
#define UMB_FUNC umbrellaUx
void checkUmbrellaUx(UTree *utree) CHECK_UMBRELLA()
#undef UMB_FUNC
#define UMB_FUNC(a,b,c) umbrellaU_GG(a,b,c,utree)
void checkUmbrellaU_GG(UTree *utree) CHECK_UMBRELLA()
#undef UMB_FUNC

inline void checkParallel(KTree *ktree, WTYPE word, IXTYPE ix) {
	ktree->Clumps[ktree->queuedClumps] = word;
	ktree->IXs[ktree->queuedClumps] = ix;
	if (++ktree->queuedClumps == FIRETHRES) 
		checkUmbrella(ktree);
}
void checkAndNullU(UTree *utree, WordIxPair pair) {
	utree->Pairs[utree->queuedClumps] = pair;
	if (++utree->queuedClumps == FIRETHRES) checkUmbrellaU(utree);
}
void checkAndNullU_GG(UTree *utree, WordIxPair pair) {
	utree->Pairs[utree->queuedClumps] = pair;
	if (++utree->queuedClumps == FIRETHRES) checkUmbrellaU_GG(utree);
}
inline void checkAndNullUx(UTree *utree, WordIxPair pair) {
	utree->Pairs[utree->queuedClumps] = pair;
	if (++utree->queuedClumps == FIRETHRES) checkUmbrellaUx(utree);
}
/* 
inline size_t umbrellaV(KMerY *tree, STYPE word, IXTYPE ix) {
	//printf("word=%llu,ix=%llu\n",word,ix);
	do { 
		if (word > tree->word) { 
			if (!tree->right) return 0; 
			tree = tree->right; 
		} 
		else if (word < tree->word) { 
			if (!tree->left) return 0; 
			tree = tree->left; 
		} 
	} while (word != tree->word); 
	if (tree->ix == BAD_IX) return 0; 
	if (ix != tree->ix) { tree->ix = BAD_IX; return 1; } 
	return 0; 
}
void checkUmbrellaV(UTree *utree) {
	size_t length = utree->queuedClumps; 
	utree->queuedClumps = 0; 
	WordIxPair *Pairs = utree->Pairs; 
	//#pragma omp parallel for schedule(dynamic,1000) \
	//	shared(utree,Pairs) reduction(+:PRUNED)
	for (size_t i = 0; i < length; ++i) { 
		WTYPE word = Pairs[i].word; 
		//printf("Word = %llu, pf=%llu, sx=%llu ", word, word >> ((PACKSIZE << 1) - PFBITS), ((word << PFBITS) >> PFBITS));
		PRUNED += umbrellaV(utree->Roots[word >> ((PACKSIZE << 1) - PFBITS)], 
			(word << PFBITS) >> PFBITS, Pairs[i].ix); 
	} 
	printf("PRUNED %llu LEAVES\n",PRUNED);
}
inline void checkAndNullV(UTree *utree, WordIxPair pair) {
	utree->Pairs[utree->queuedClumps] = pair;
	if (++utree->queuedClumps == FIRETHRES) checkUmbrellaV(utree);
}
 */
inline void checkParallel_noBal(KTree *ktree, WTYPE word, IXTYPE ix) {
	ktree->Clumps[ktree->queuedClumps] = word;
	ktree->IXs[ktree->queuedClumps] = ix;
	if (++ktree->queuedClumps == FIRETHRES) 
		checkUmbrella_noBal(ktree);
}

void traceBalance(KMerX *tree, KMerX **array, size_t *ix) {
	if (tree->left) traceBalance(tree->left, array, ix);
	array[(*ix)++] = tree; // if on top, DFS. If mid, IOS, if bot: LFS
	if (tree->right) traceBalance(tree->right, array, ix);
}
void traceBalanceU(KMerY *tree, KMerY **array, size_t *ix) {
	if (tree->left) traceBalanceU(tree->left, array, ix);
	array[(*ix)++] = tree; // if on top, DFS. If mid, IOS, if bot: LFS
	if (tree->right) traceBalanceU(tree->right, array, ix);
}
void traceBalanceD(KMerX *tree, KMerX *array, size_t *ix) {
	if (tree->left) traceBalanceD(tree->left, array, ix);
	array[(*ix)++] = *tree; // if on top, DFS. If mid, IOS, if bot: LFS
	if (tree->right) traceBalanceD(tree->right, array, ix);
}
void traceBalancePurge(KMerX *tree, KMerX **array, size_t *ix, size_t *cnt) {
	if (tree->left) traceBalancePurge(tree->left, array, ix, cnt);
	if (tree->ix != BAD_IX) *cnt+=tree->count, array[(*ix)++] = tree; 
	//else printf("hah\n");
	if (tree->right) traceBalancePurge(tree->right, array, ix,cnt);
}
void traceBalancePurgeU(KMerY *tree, KMerY **array, size_t *ix, size_t *cnt) {
	if (tree->left) traceBalancePurgeU(tree->left, array, ix, cnt);
	if (tree->ix < EMPTY_IX) {
		#ifndef NO_COUNT
		*cnt+=tree->count;
		#endif
		array[(*ix)++] = tree; 
	}
	//else printf("hah\n");
	if (tree->right) traceBalancePurgeU(tree->right, array, ix,cnt);
}

inline int binS1( KMerX *array[], size_t size, WTYPE key, IXTYPE ix ) {
  //if( !array || !size ) return 0;
  KMerX **p=array;
  while( size > 8 ){
    size_t w=size >> 1;
    if( p[w+1]->word <= key ){ p+=w+1; size-=w+1; } else  size = w;
  }
  if( size==8 ){ if( p[5]->word <=  key ){ p+=5; size=3; } else size=4; }
  if( size==6 ){ if( p[4]->word <=  key ){ p+=4; size=2; } else size=3; }
  if( size==5 ){ if( p[3]->word <=  key ){ p+=3; size=2; } else size=2; }
  if( size==4 ){ if( p[3]->word <=  key ){ p+=3; size=1; } else size=2; }
  if( size==2 ){ if( p[2]->word <=  key ){ p+=2; size=0; } else size=1; }

  if( size==7 ){ if( p[4]->word <=  key ){ p+=4; size=3; } else size=3; }
  if( size==3 ){ if( p[2]->word <=  key ){ p+=2; size=1; } else size=1; }
  if( size==1 ){ if( p[1]->word <=  key ){ p+=1;         }              }
  /* switch(size) {
    case 7: if( p[4]->word <= key ) p+=4;
    case 3: if( p[2]->word <= key ) p+=2;
    case 1: if( p[1]->word <= key ) p+=1;
  } */
	if (p[0]->word != key || p[0]->ix == BAD_IX) return 0; 
	if (p[0]->ix != ix) { p[0]->ix = BAD_IX; return 1; }
	return 0;
  //*index=p-array; return p[0].word==key;
}

inline int binsearch_7( KMerX *array[], size_t size, WTYPE key, IXTYPE ix ){
  KMerX **p=array;
  size_t w=(size-1)>>1; w|=w>>1; w|=w>>2; w|=w>>4; w|=w>>8; w|=w>>16;
#if SIZE_MAX == UINT64_MAX
  w|=w>>32;
#endif
  if( p[w]->word<key ) p+=size-w-1;
  switch( w ){
#define C(n) case ((size_t)1<<n)-1: /* \
	if( p[(size_t)1<<(n-1)]->word==key ) { \
		if (ix != p[(size_t)1<<(n-1)]->ix) { \
			p[(size_t)1<<(n-1)]->ix = BAD_IX; \
			return 1; \
		} \
		else return 0; \
	} */ \
	if( p[(size_t)1<<(n-1)]->word<=key ) p+=(size_t)1<<(n-1);
#if SIZE_MAX == UINT64_MAX
                                              C(63) C(62) C(61)
    C(60) C(59) C(58) C(57) C(56) C(55) C(54) C(53) C(52) C(51)
    C(50) C(49) C(48) C(47) C(46) C(45) C(44) C(43) C(42) C(41)
    C(40) C(39) C(38) C(37) C(36) C(35) C(34) C(33) C(32)
#endif
                                                          C(31)
    C(30) C(29) C(28) C(27) C(26) C(25) C(24) C(23) C(22) C(21)
    C(20) C(19) C(18) C(17) C(16) C(15) C(14) C(13) C(12) C(11)
    C(10) C( 9) C( 8) C( 7) C( 6) C( 5) C( 4) C( 3) C( 2) C( 1)
#undef C
  }
  if (p[0]->word != key || p[0]->ix == BAD_IX) return 0;
  if (p[0]->ix != ix) { p[0]->ix = BAD_IX; return 1; }
  return 0;
  //*index=p-array; return p[0]==key;
}

inline int binSP( KMerX *array[], size_t size, WTYPE key, IXTYPE ix ) {
	//if( !array || !size ) return 0;
	KMerX **p=array;
	while (size) {
		size_t w=size >> 1;
		/* if (p[w+1]->word == key) {
			if (p[w+1]->ix == BAD_IX) return 0;
			if (p[w+1]->ix != ix) { p[w+1]->ix = BAD_IX; return 1; }
		} */
		if (p[w+1]->word <= key) p+=w+1, size-=w+1; 
		else size = w;
	}
	if (p[0]->word != key || p[0]->ix == BAD_IX) return 0; 
	if (p[0]->ix != ix) { p[0]->ix = BAD_IX; return 1; }
	return 0;
}
void fireCheckArrayP(KTree *ktree, KMerX **array) {
	size_t length = ktree->queuedClumps;
	ktree->queuedClumps = 0;
	WTYPE *Words = ktree->Clumps;
	IXTYPE *IXs = ktree->IXs;
	size_t arrMax = *ktree->NumsInserted -1;
	
	//KMerX *root = *ktree->Roots;
	#pragma omp parallel for \
		schedule(dynamic,1000) \
		shared(array,Words,IXs)
	for (size_t i = 0; i < length; ++i) {
		binS1(array, arrMax, Words[i], IXs[i]);
	}
}
inline void checkBinaryP(KTree *ktree, KMerX **array, WTYPE word, IXTYPE ix) {
	ktree->Clumps[ktree->queuedClumps] = word;
	ktree->IXs[ktree->queuedClumps] = ix;
	if (++ktree->queuedClumps == FIRETHRES) 
		fireCheckArrayP(ktree, array);
}
KMerX **createArrayP(KMerX *tree, size_t sz) {
	size_t ix = 0;
	KMerX **array = malloc(sizeof(*array) * sz);
	traceBalance(tree, array, &ix);
	return array;
}

// get in tree (known existence)
size_t giTree(KMerX *tree, WTYPE word) {
	do {
		if (word > tree->word) tree = tree->right; 
		else if (word < tree->word) tree = tree->left;
	} while (word != tree->word);
	return tree->count;
}
// merge trees
void meTree(KMerX *tree, KMerX *tree2, size_t *totals) {
	KMerX *left = tree2->left, *right = tree2->right;
	*totals += meNode(tree,tree2);
	if (left) meTree(tree, left, totals);
	if (right) meTree(tree, right, totals);
}

void traceCnt(KMerX *tree, size_t *ix) {
	
	if (tree->left) traceCnt(tree->left, ix);
	++*ix;
	if (tree->right) traceCnt(tree->right, ix);
	
}
void buildBalanceL(KMerX *tree, KMerX **array, size_t sz);
void buildBalanceR(KMerX *tree, KMerX **array, size_t sz);
void buildBalanceLU(KMerY *tree, KMerY **array, size_t sz);
void buildBalanceRU(KMerY *tree, KMerY **array, size_t sz);
void buildBalanceLd(KMerX *tree, KMerX *array, size_t sz, size_t *cnt);
void buildBalanceRd(KMerX *tree, KMerX *array, size_t sz, size_t *cnt);
void buildBalanceLdU(KMerY *tree, KMerY *array, size_t sz, size_t *cnt);
void buildBalanceRdU(KMerY *tree, KMerY *array, size_t sz, size_t *cnt);

#define BUILDBALANCE() \
	if (!sz) { \
		CHILD = *array; \
		CHILD->left = 0; \
		CHILD->right = 0; \
		return; \
	} \
	size_t ix = sz >> 1; \
	CHILD = array[ix]; \
	if (ix) buildBalanceL(CHILD,array,ix-1); \
	else CHILD->left = 0; \
	buildBalanceR(CHILD,array+(ix+1), sz-(ix+1));

#define BUILDBALANCEU() \
	if (!sz) { \
		CHILD = *array; \
		CHILD->left = 0; \
		CHILD->right = 0; \
		return; \
	} \
	size_t ix = sz >> 1; \
	CHILD = array[ix]; \
	if (ix) buildBalanceLU(CHILD,array,ix-1); \
	else CHILD->left = 0; \
	buildBalanceRU(CHILD,array+(ix+1), sz-(ix+1));
#ifdef NO_COUNT
	#define SUM_COUNTS() {}
#else
	#define SUM_COUNTS() *cnt += CHILD->count;
#endif
#define BUILDBALANCEDIRECT() \
	if (!sz) { \
		CHILD = array; \
		CHILD->left = 0; \
		CHILD->right = 0; \
		SUM_COUNTS() \
		return; \
	} \
	size_t ix = sz >> 1; \
	CHILD = array + ix; \
	SUM_COUNTS() \
	if (ix) LDBUILD(CHILD,array,ix-1, cnt); \
	else CHILD->left = 0; \
	RDBUILD(CHILD,array+(ix+1), sz-(ix+1),cnt);

// set a branch of the given tree, and recurse with that branch as root
void buildBalanceL(KMerX *tree, KMerX **array, size_t sz) {
	#define CHILD tree->left
		BUILDBALANCE()
	#undef CHILD
}
void buildBalanceR(KMerX *tree, KMerX **array, size_t sz) {
	#define CHILD tree->right
		BUILDBALANCE()
	#undef CHILD
}
void buildBalanceLU(KMerY *tree, KMerY **array, size_t sz) {
	#define CHILD tree->left
		BUILDBALANCEU()
	#undef CHILD
}
void buildBalanceRU(KMerY *tree, KMerY **array, size_t sz) {
	#define CHILD tree->right
		BUILDBALANCEU()
	#undef CHILD
}

#define LDBUILD buildBalanceLd
#define RDBUILD buildBalanceRd
void buildBalanceLd(KMerX *tree, KMerX *array, size_t sz, size_t *cnt) {
	#define CHILD tree->left
		BUILDBALANCEDIRECT()
	#undef CHILD
}
void buildBalanceRd(KMerX *tree, KMerX *array, size_t sz, size_t *cnt) {
	#define CHILD tree->right
		BUILDBALANCEDIRECT()
	#undef CHILD
}
#undef LDBUILD
#undef RDBUILD

#define LDBUILD buildBalanceLdU
#define RDBUILD buildBalanceRdU
void buildBalanceLdU(KMerY *tree, KMerY *array, size_t sz, size_t *cnt) {
	#define CHILD tree->left
		BUILDBALANCEDIRECT()
	#undef CHILD
}
void buildBalanceRdU(KMerY *tree, KMerY *array, size_t sz, size_t *cnt) {
	#define CHILD tree->right
		BUILDBALANCEDIRECT()
	#undef CHILD
}
#undef LDBUILD
#undef RDBUILD
char * print_bignum(WTYPE n, char *str) {
	//char str[40] = {0}; // log10(1 << 128) + '\0'
	if (n == 0) return str;
	char *s = str + 39;
	while (n != 0) {
		
		*--s = "0123456789"[n % 10];
		n /= 10;
	}
	return s;
}
void traceTree(KMerX *tree, FILE *of) {
	if (tree->left) traceTree(tree->left, of);
	if (tree->ix != BAD_IX) {
		static char str[40] = {0};
		fprintf(of,"%s\t%s\t%llu\t%llu\n",num2word(tree->word,WORDTEMP),
			print_bignum(tree->word,str),(uint64_t)tree->count,(uint64_t)tree->ix);
	}	
	if (tree->right) traceTree(tree->right, of);
}
void traceTreeB(KMerX *tree, FILE *of) {
	if (tree->left) traceTreeB(tree->left, of);
	if (tree->ix != BAD_IX) {
		fwrite(tree,sizeof(tree->word)+sizeof(tree->count)+sizeof(tree->ix),1,of);
		//fwrite(&tree->word,sizeof(WTYPE),1,of);
		//fwrite(&tree->count,sizeof(CNTTYPE),1,of);
		//fwrite(&tree->ix,sizeof(IXTYPE),1,of);
	}	
	if (tree->right) traceTreeB(tree->right, of);
}
void traceTreeBU(PFTYPE i, KMerY *tree, FILE *of) {
	if (tree->left) traceTreeBU(i, tree->left, of);
	if (tree->ix < EMPTY_IX) {
		//fwrite(tree,sizeof(WTYPE)+sizeof(tree->count)+sizeof(tree->ix),1,of);
		WTYPE word = ((WTYPE)i << (2*PACKSIZE - PFBITS)) + tree->word;
		//printf("word=%s\n",num2word(word,WORDTEMP));
		fwrite(&word,sizeof(word),1,of);
		#ifndef NO_COUNT
		fwrite(&tree->count,sizeof(CNTTYPE),1,of);
		#endif
		fwrite(&tree->ix,sizeof(IXTYPE),1,of);
	}	
	if (tree->right) traceTreeBU(i, tree->right, of);
}
void traceTreeBUf(PFTYPE i, KMerY *tree, uint64_t *cnts, FILE *of) {
	if (tree->left) traceTreeBUf(i, tree->left, cnts, of);
	if (tree->ix < EMPTY_IX) {
		//fwrite(tree,sizeof(WTYPE)+sizeof(tree->count)+sizeof(tree->ix),1,of);
		WTYPE word = ((WTYPE)i << (2*PACKSIZE - PFBITS)) + tree->word;
		++cnts[tree->ix];
		//printf("word=%s\n",num2word(word,WORDTEMP));
		fwrite(&word,sizeof(word),1,of);
		#ifndef NO_COUNT
		fwrite(&tree->count,sizeof(CNTTYPE),1,of);
		#endif
		fwrite(&tree->ix,sizeof(IXTYPE),1,of);
	}	
	if (tree->right) traceTreeBUf(i, tree->right, cnts, of);
}
void traceTreeBF(KMerX *tree, FILE *of) {
	if (tree->left) traceTreeBF(tree->left, of);
	fwrite(tree,sizeof(tree->word)+sizeof(tree->count)+sizeof(tree->ix),1,of);
	if (tree->right) traceTreeBF(tree->right, of);
}
void traceTreeF(KMerX *tree, FILE *of) {
	if (tree->left) traceTreeF(tree->left, of);
	static char str[40] = {0};
	 fprintf(of,"%s\t%s\t%llu\t%llu\n",num2word(tree->word,WORDTEMP),
		print_bignum(tree->word,str),(uint64_t)tree->count,(uint64_t)tree->ix);
	if (tree->right) traceTreeF(tree->right, of);
}
void traceTreeDetail(KMerX *tree, int depth) {
	printf("%d\t%s\t%llu\n",depth, num2word(tree->word,WORDTEMP),tree->count);
	if (tree->left) traceTreeDetail(tree->left, depth+1);
	if (tree->right) traceTreeDetail(tree->right, depth+1);
}
void buildDepth(KMerX *node, int depth, int *depthMax, size_t *depthTot,
size_t *count) {
	if (node->left) buildDepth(node->left,depth+1,depthMax,depthTot,count);
	if (depth > *depthMax) *depthMax = depth;
	++(*count);
	(*depthTot) += depth;
	//printf("%s\t%I64u\n",num2word(tree->word,WORDTEMP),tree->count);
	if (node->right) buildDepth(node->right,depth+1,depthMax,depthTot,count);
}
void reportAvMaxDepth(KMerX *tree) {
	int depthMax = 0;
	size_t count = 0, depthTot=0;
	buildDepth(tree,1,&depthMax, &depthTot, &count);
	double depthAv = (double)(depthTot)/count;
	printf("Total nodes = %lu. Max depth=%d, Avg=%f\n",count,depthMax,depthAv);
}
int tfs_cmp(const void *a, const void *b) {
	KMerX *b1 = *(KMerX **)a, *b2 = *(KMerX **)b;
	//return (**(KMerX **)a).count < (**(KMerX **)b).count ? -1 :
	//	(*(KMerX **)a)->count > (*(KMerX **)b)->count;
	return (b1->count > b2->count) ? -1 : (b1->count < b2->count);
}
void treeFreqSort(KMerX **arr, size_t n) {
#ifdef USE_QSORT
	#define NODEFREQGT(a,b) ((*a)->count > (*b)->count)
	QSORT(KMerX*, arr, n, NODEFREQGT);
	#undef NODEFREQGT
#else
	qsort(arr, n, sizeof(*arr), tfs_cmp);
#endif
}
#ifndef NO_COUNT
	int tfsu_cmp(const void *a, const void *b) {
		KMerY *b1 = *(KMerY **)a, *b2 = *(KMerY **)b;
		//return (**(KMerX **)a).count < (**(KMerX **)b).count ? -1 :
		//	(*(KMerX **)a)->count > (*(KMerX **)b)->count;
		return (b1->count > b2->count) ? -1 : (b1->count < b2->count);
	}
	void treeFreqSortU(KMerY **arr, size_t n) {
	#ifdef USE_QSORT
		#define NODEFREQGT(a,b) ((*a)->count > (*b)->count)
		QSORT(KMerY*, arr, n, NODEFREQGT);
		#undef NODEFREQGT
	#else
		qsort(arr, n, sizeof(*arr), tfsu_cmp);
	#endif
	}
#endif
int tns_cmp(const void *a, const void *b) {
	KMerX *b1 = *(KMerX **)a, *b2 = *(KMerX **)b;
	//return (**(KMerX **)a).count < (**(KMerX **)b).count ? -1 :
	//	(*(KMerX **)a)->count > (*(KMerX **)b)->count;
	return (b1->word < b2->word) ? -1 : (b1->word > b2->word);
}
void treeNameSort(KMerX **arr, size_t n) {
#ifdef USE_QSORT
	#define NODENAMELT(a,b) ((*a)->word < (*b)->word)
	QSORT(KMerX*, arr, n, NODENAMELT);
	#undef NODENAMELT
#else
	qsort(arr, n, sizeof(*arr), tns_cmp);
#endif
}
int tnsu_cmp(const void *a, const void *b) {
	KMerY *b1 = *(KMerY **)a, *b2 = *(KMerY **)b;
	//return (**(KMerX **)a).count < (**(KMerX **)b).count ? -1 :
	//	(*(KMerX **)a)->count > (*(KMerX **)b)->count;
	return (b1->word < b2->word) ? -1 : (b1->word > b2->word);
}
void treeNameSortU(KMerY **arr, size_t n) {
#ifdef USE_QSORT
	#define NODENAMELT(a,b) ((*a)->word < (*b)->word)
	QSORT(KMerY*, arr, n, NODENAMELT);
	#undef NODENAMELT
#else
	qsort(arr, n, sizeof(*arr), tnsu_cmp);
#endif
}
KMerX * balanceTree(KMerX *tree, size_t sz, size_t totalCount) {
	// set limits
	#define MAX_NODES 1000000
	#define TOP_SHIFT 5
	if (sz > MAX_NODES) return tree;
	size_t ix = 0;
	KMerX **array = malloc(sizeof(*array) * (sz+1));
	traceBalance(tree, array, &ix);
	//printf("traceBalance uncovered %llu nodes. Sz+1 claims %llu.\n",ix,sz+1);
	//free(array); return tree;
	// experimental intervention: frequency-first tree construction
	treeFreqSort(array, ix);
	
	// Adaptive threshold determination
	size_t limit = 0;
	size_t thres = 0, cutoff = totalCount >> TOP_SHIFT;
	while ((thres += array[limit++]->count) < cutoff); //limit < ix && 
	//while (++limit <= sz && array[0]->count/array[limit]->count < 4); 
	//printf("limit = %lld out of totalCount %llu\n",limit,totalCount);
	tree = array[0];
	tree->left = 0; tree->right=0;
	
	if (limit > 2) {
		for (size_t i = 1; i < limit; ++i) reTree(tree,array[i]);
		
		// balance the top
		KMerX **top = malloc(sizeof(*top)* limit);
		for (size_t i = 0; i < limit; ++i) top[i] = array[i];
		treeNameSort(top, limit);
		ix = (limit-1)/2;
		tree = top[ix];
		buildBalanceL(tree, top, ix-1);
		buildBalanceR(tree, top + (ix+1), limit - 1 - (ix+1));
		free (top);
	} else limit = 1;
	size_t limit2 = (sz+1);
	
	// Add in the rest by staccade
	if (limit2 > limit) {
		int L = 1;
		for (long long i = limit; i < limit2-1; ++i) {
			reTree(tree,array[i+L]);
			L = -L;
		}
		if (L==-1) reTree(tree,array[limit2-2]);
		else reTree(tree,array[limit2-1]);
	}
	
	free(array);
	return tree;
	#undef TOP_SHIFT
}

#ifndef NO_COUNT
KMerY * balanceTreeU(KMerY *tree, size_t sz, size_t totalCount) {
	// set limits
	#define MAX_NODES 1000000
	#define TOP_SHIFT 3
	if (sz > MAX_NODES) return tree;
	size_t ix = 0;
	KMerY **array = malloc(sizeof(*array) * sz);
	traceBalanceU(tree, array, &ix);
	treeFreqSortU(array, ix);
	
	// Adaptive threshold determination
	size_t limit = 0;
	size_t thres = 0, cutoff = totalCount >> TOP_SHIFT;
	while ((thres += array[limit++]->count) < cutoff); //limit < ix && 
	tree = array[0];
	tree->left = 0; tree->right=0;
	
	if (limit > 2) {
		for (size_t i = 1; i < limit; ++i) reTreeU(tree,array[i]);
		// balance the top
		KMerY **top = malloc(sizeof(*top)* limit);
		for (size_t i = 0; i < limit; ++i) top[i] = array[i];
		treeNameSortU(top, limit);
		ix = (limit-1)/2;
		tree = top[ix];
		buildBalanceLU(tree, top, ix-1);
		buildBalanceRU(tree, top + (ix+1), limit - 1 - (ix+1));
		free (top);
	} else limit = 1;
	size_t limit2 = sz;
	
	// Add in the rest by staccade
	if (limit2 > limit) {
		int L = 1;
		for (long long i = limit; i < limit2-1; ++i) {
			reTreeU(tree,array[i+L]);
			L = -L;
		}
		if (L==-1) reTreeU(tree,array[limit2-2]);
		else reTreeU(tree,array[limit2-1]);
	}
	
	free(array);
	return tree;
	#undef TOP_SHIFT
}
#endif

KMerX *simpleBalance(KMerX *tree, size_t sz) {
	size_t ix = 0;
	KMerX **array = malloc(sizeof(*array) * sz);
	traceBalance(tree, array, &ix);
	ix = --sz >> 1;
	tree = array[ix];
	buildBalanceL(tree, array, ix - 1);
	buildBalanceR(tree, array + (ix+1), sz - (ix+1));
	free(array);
	return tree;
}
inline KMerY *simpleBalanceU(KMerY *tree, size_t sz) {
	//if (sz < 3) return tree;
	size_t ix = 0;
	//KMerY **array = malloc(sizeof(*array) * sz);
	KMerY *array[sz];
	traceBalanceU(tree, array, &ix);
	ix = --sz >> 1;
	tree = array[ix];
	buildBalanceLU(tree, array, ix - 1);
	buildBalanceRU(tree, array + (ix+1), sz - (ix+1));
	//free(array);
	return tree;
}
/* inline KMerY *simpleBalanceUX(KMerY *tree, size_t sz, KMerY **array) {
	size_t ix = 0;
	//KMerY **array = malloc(sizeof(*array) * sz);
	traceBalanceU(tree, array, &ix);
	ix = --sz >> 1;
	tree = array[ix];
	buildBalanceLU(tree, array, ix - 1);
	buildBalanceRU(tree, array + (ix+1), sz - (ix+1));
	//free(array);
	return tree;
} */
inline KMerY *simpleBalancePurgeU(KMerY *tree, size_t *sz, size_t *cnt) {
	if (!*sz) return tree;
	size_t nodes = 0, total = 0;
	//KMerY **array = malloc(sizeof(*array) * *sz);
	KMerY *array[*sz];
	//(KMerY *tree, KMerY **array, size_t *ix, size_t *cnt) {
	traceBalancePurgeU(tree, array, &nodes, &total);
	//exit(1);
	*sz = nodes, *cnt = total; // update original tree
	if (!nodes) {
		#ifdef NO_COUNT
			*tree = (KMerY){0,EMPTY_IX,0,0};
		#else
			*tree = (KMerY){0,0,EMPTY_IX,0,0};
		#endif
		//free(array);
		return tree;
	}
	if (nodes==1) {
		tree = *array;
		tree->right = 0, tree->left = 0;
		//free(array);
		return tree;
	}
	size_t ix = --nodes >> 1;
	tree = array[ix];
	if (ix) buildBalanceLU(tree, array, ix - 1);
	buildBalanceRU(tree, array + (ix+1), nodes - (ix+1));
	//free(array);
	
	return tree;
}

inline void clumpParachute(KTree *ktree) {
	size_t length = ktree->queuedClumps;
	ktree->queuedClumps = 0;
	#pragma omp parallel for schedule(dynamic,1000) shared(ktree)
	for (size_t i = 0; i < length; ++i) {
		int tid = 0;
		#ifdef _OPENMP
		tid = omp_get_thread_num();
		#endif
		++ktree->TotalCounts[tid]; 
		if (!ktree->Roots[tid]->count) { 
			*(ktree->Roots[tid]) = (KMerX){ktree->Clumps[i],1,ktree->IXs[i],0,0}, 
				ktree->NumsInserted[tid]=1; 
			continue;
		}
		ktree->NumsInserted[tid] += xeTree(ktree->Roots[tid],ktree->Clumps[i],
			ktree->IXs[i],tid); 
		if (ktree->NumsInserted[tid] >= ktree->BalanceThreshes[tid]) { 
			//printf("Balancing tree (tid %d) at %lu\n",tid,ktree->NumsInserted[tid]); 
			ktree->Roots[tid] = balanceTree(ktree->Roots[tid],ktree->NumsInserted[tid]-1, 
				ktree->TotalCounts[tid]); 
			ktree->BalanceThreshes[tid]=(ktree->BalanceThreshes[tid]+1)*2-1;  
		}
	}
}

void mergeParachutes(KTree *ktree) {
	ktree->totalCount = *ktree->TotalCounts; 
	ktree->numInserted = *ktree->NumsInserted;
	size_t T = ktree->numThreads;
	for (size_t i = 1; i < T; ++i) {
		if (!ktree->Roots[i]->count) continue;
		ktree->totalCount += ktree->TotalCounts[i];
		meTree(*ktree->Roots,ktree->Roots[i],&ktree->numInserted);
		ktree->TotalCounts[i] = 0;
		ktree->NumsInserted[i] = 0;
		ktree->Roots[i] = malloc(sizeof(*ktree->Roots[i]));
		*ktree->Roots[i] = (KMerX){0,0,BAD_IX,0,0};
	}
	ktree->TotalCounts[0] = ktree->totalCount;
	ktree->NumsInserted[0] = ktree->numInserted;
}

size_t findRarestK(KMerX *tree, WTYPE *seq, uint16_t length) {
	size_t numPacks = length/PACKSIZE;
	size_t min = (size_t)-1, cur;
	for (int i = 0; i < numPacks; ++i) {
		cur = giTree(tree, seq[i]);
		//printf("%llu, ", cur);
		if (cur < min) min = cur;
	}
	return min;
}

size_t findRarestK_FL(KMerX *tree, WTYPE *seq, uint16_t length) {
	size_t numPacks = length/PACKSIZE;
	//if (numPacks * PACKSIZE < length) ++numPacks;
	size_t min = (size_t)-1, cur;
	for (int i = 0; i < numPacks; ++i) {
		cur = giTree(tree, seq[i]);
		//printf("%llu, ", cur);
		if (cur < min) min = cur;
	}
	
	if (numPacks * PACKSIZE < length) { // handle endpiece
		unsigned mod = length % PACKSIZE; // guarantee: never 0
		// rightshift by 2xmodulo
		WTYPE prev = (seq[numPacks-1] << (2*mod)) + (seq[numPacks] >> (2*(PACKSIZE-mod)));
		cur = fiTree(tree, prev);
		if (cur < min) min = cur;
	}
	//printf("\n");
	return min;
} 

inline size_t findRarestK2(KMerX *tree, WTYPE *seq, uint16_t length) {
	size_t min = giTree(tree,*seq), cur;
	unsigned offset = 0, basePack = 1;
	for (int i = 1, b=length-PACKSIZE+1; i < b; ++i) {
		if (++offset == PACKSIZE) 
			cur = giTree(tree, seq[basePack]), 
			++basePack, offset = 0;
		else cur = giTree(tree, (*(seq+basePack-1) << (offset << 1)) + 
				(*(seq+basePack) >> ((PACKSIZE-offset) << 1)));
		//printf("%llu [%s=%u:%u], ", cur,num2word(this,WORDTEMP),offset,basePack);
		//printf("[%llu] ",cur);
		if (cur < min) min = cur;
	}
	//printf("MIN=%llu\n",min);
	return min;
}



/************************************************
          USER-ACCESSIBLE FUNCTIONS
************************************************/

void KT_addWordIx(KTree *ktree, WTYPE word, IXTYPE ix) {
	ktree->synced = 0;
	ktree->Clumps[ktree->queuedClumps] = word; 
	ktree->IXs[ktree->queuedClumps] = ix;
	if (++ktree->queuedClumps == FIRETHRES) 
		clumpParachute(ktree); 
}
#ifdef NO_COUNT
	#define CREATE_NEW_ROOT() *utree->Roots[prefix] = \
	(KMerY){suffix,ix,0,0}, utree->NumsInserted[prefix]=1; 
#else
	#define CREATE_NEW_ROOT() *utree->Roots[prefix] = \
	(KMerY){suffix,1,ix,0,0}, utree->NumsInserted[prefix]=1; 
#endif
#define ADDWORDIX() \
	PFTYPE prefix = word >> ((PACKSIZE << 1) - PFBITS); \
	STYPE suffix = (word << PFBITS) >> PFBITS; \
	++utree->TotalCounts[prefix]; \
	if (utree->Roots[prefix]->ix == EMPTY_IX) {  \
		CREATE_NEW_ROOT() \
		/* ++utree->SampCnts[ix]; */ \
		return; \
	} \
	if (TREE_ADD(utree->Roots[prefix],suffix,ix)==1) ++utree->NumsInserted[prefix]; \
	if (utree->NumsInserted[prefix] == utree->BalanceThreshes[prefix]) { \
		/* if (utree->NumsInserted[prefix] < BALBUFSZ) \
			utree->Roots[prefix] = simpleBalanceUX(utree->Roots[prefix], \
				utree->NumsInserted[prefix], BALBUF); \
		else */ utree->Roots[prefix] = simpleBalanceU(utree->Roots[prefix], \
			utree->NumsInserted[prefix]); \
		utree->BalanceThreshes[prefix] = utree->BalanceThreshes[prefix] > 1000 ? 0 : \
			(utree->BalanceThreshes[prefix]+1)*2-1; \
	} 
void UT_addWordIx(UTree *utree, WTYPE word, IXTYPE ix) {
	int status;
	#define TREE_ADD(t,s,x) status=xeTreeU(t,s,x)
	ADDWORDIX()
	#undef TREE_ADD
	//utree->SampCnts[ix] += status;
}

void UT_addWordIxGG(UTree *utree, WTYPE word, IXTYPE ix) {
	long status;
	#define TREE_ADD(t,s,x) status=xeTreeU_GG(t,s,x,utree)
	ADDWORDIX()
	#undef TREE_ADD
	/* if (status > 1)  // convert ix
		--utree->SampCnts[ix], ++utree->SampCnts[status-2];
	else utree->SampCnts[ix] += status; */
	
}

void KT_sync(KTree *ktree) {
	if (ktree->queuedClumps) clumpParachute(ktree);
	if (ktree->numThreads > 1) mergeParachutes(ktree);
	ktree->synced = 1;
}

void KT_simpleBalancePurge(KTree *ktree) {
	if (!ktree->synced) KT_sync(ktree);
	KMerX *tree = *ktree->Roots;
	size_t sz = *ktree->NumsInserted;
	size_t ix = 0, totCnt = 0;
	KMerX **array = malloc(sizeof(*array) * sz);
	traceBalancePurge(tree, array, &ix, &totCnt);
	//printf("Pruned %llu nodes.\n",sz - ix);
	*ktree->NumsInserted = ix;
	*ktree->TotalCounts = totCnt;
	//ktree->numInserted = *ktree->NumsInserted;
	
	sz = ix - 1;
	ix = sz >> 1;
	tree = array[ix];
	buildBalanceL(tree, array, ix - 1);
	buildBalanceR(tree, array + (ix+1), sz - (ix+1));
	free(array);
	*ktree->Roots = tree;
	//return tree;
}

IXTYPE KT_findIx(KTree *ktree, WTYPE word) {
	if (!ktree->synced) KT_sync(ktree);
	return ixTree(*ktree->Roots, word);
}

inline IXTYPE UT_findIx(UTree *utree, WTYPE word) {
	return ixTreeU(utree->Roots[word >> ((PACKSIZE << 1) - 
		PFBITS)], (word << PFBITS) >> PFBITS);
}

IXTYPE KT_findIxCount(KTree *ktree, WTYPE word, size_t *count) {
	if (!ktree->synced) KT_sync(ktree);
	return ixCntTree(*ktree->Roots, word, count);
} 

IXTYPE UT_findIxCount(UTree *utree, WTYPE word, CNTTYPE *count) {
	KMerY *node = getNodeU(utree, word);
	#ifndef NO_COUNT
	*count = node->count;
	#endif
	return node->ix;
} 

WTYPE KT_word2num(char *str) {
	if (!INIT_K) initConverter();
	WTYPE x = *(C2Xb+*str++);
	do x<<=2u, x+=*(C2Xb+*str); while (*++str);
	return x;
}

char * KT_num2word(WTYPE word) {
	if (!INIT_K) initConverter();
	return num2word(word, WORDTEMP);
}

size_t KT_parseSampFasta(KTree *ktree, char* filename) {
	FILE *fp = fopen(filename, "rb");
	if (fp == NULL) { puts("Invalid input FASTA"); return 0; }
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1); 
	ktree->synced = 0;
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix;
		if (!ktree->Samps) {
			ktree->Samps = malloc(sizeof(*ktree->Samps));
			char *str = malloc(strlen(line));
			strcpy(str,line+1);
			*ktree->Samps = (SampX){str,ix=0,0,0};
			ktree->SampStrings = malloc(sizeof(*ktree->SampStrings)*ktree->sampStringSz);
			*ktree->SampStrings = str;
		}
		else ix = addSample(ktree,line+1);
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		
		// add clumps and indices to tree
		int z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) KT_addWordIx(ktree, word, ix);
		}
	}
	fclose(fp); free(line); // purge buffers
	return ns-1; // number of sequences parsed
}

size_t UT_parseSampFasta(UTree *utree, char* filename) {
	FILE *fp = fopen(filename, "rb");
	if (fp == NULL) { puts("Invalid input FASTA"); return 0; }
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1);  // ktree
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSampleU(utree,line+1);
		
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		
		// add clumps and indices to tree
		int z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) UT_addWordIx(utree, word, ix);
		}
	}
	fclose(fp); free(line); // purge buffers
	return ns-1; // number of sequences parsed
}

inline size_t crBST(char *key, size_t sz, char **String) {
	char **p = String;
	while (sz) {
		size_t w = sz >> 1; 
		char *ref_s = *(p+w+1), *key_s = key;
		
		while (*ref_s == *key_s++) if (!*ref_s++) return p+w+1-String; 
		if (*ref_s < *(key_s-1)) { p+=w+1; sz-=w+1; }
		else sz = w;
	}
	char *ref_s = *p, *key_s = key;
	while (*ref_s == *key_s++) if (!*ref_s++) return p - String;
	return -1;
	//return p - String; // replace last 3 lines for unsave ver
}

inline int xcmp(str1, str2) register const char *str1, *str2; {
	while (*str1 == *str2++) if (!*str1++) return 0; 
	return (*(const unsigned char *)str1 - *(const unsigned char *)(str2 - 1));
}

int xcmpP(const void *str1, const void *str2) {
	return xcmp(**(char ***)str1, **(char ***)str2);
}

size_t UT_parseSampFastaGG(UTree *utree, char* filename, char* labels, int doGG) {
	FILE *fp = fopen(filename, "rb"), *fp2 = fopen(labels, "rb");
	if (fp == 0 || fp2 == 0) { puts("Invalid input FASTA"); return 0; }
	// read in the second file
	fseek(fp2,0,SEEK_END); size_t filesz = ftell(fp2); rewind(fp2);
	char *dump = malloc(filesz+1); fread(dump,filesz,1,fp2); fclose(fp2);
	dump[filesz] = 0;
	size_t lines = 0;
	char *ptr = dump; do if (*ptr == '\n') ++lines; while (*++ptr);
	printf("Lines = %llu\n",lines); 
	char **taxList = malloc(sizeof(*taxList)*lines);
	char **ixList = malloc(sizeof(*ixList)*lines);
	FILE *outfile = fopen("outfile_temp_db.txt","wb");
	ptr = dump; // - 1; //while (*++ptr) {
	for (size_t i = 0; i < lines; ++i) {
		ixList[i] = ptr; // store first string as key
		while (*++ptr != '\t'); // skip to the tab
		*ptr++ = 0; // replace tab with null
		taxList[i] = ptr; // store second string as taxon
		while (*++ptr != '\n'); // get to end of line
		*ptr++ = 0; // replace newline with null
		//fprintf(outfile,"%s=%s\n",ixList[i],taxList[i]);
	}
	// sorting by pointers can be done here; but now assume sorted 2-col map (by col 1)
	char ***Pointers = malloc(sizeof(*Pointers)*lines);
	for (size_t i = 0; i < lines; ++i) Pointers[i] = &ixList[i];
	qsort(Pointers,lines,sizeof(*Pointers),xcmpP);
	char **ixSorted = malloc(sizeof(*ixSorted)*lines),
		 **taxSorted = malloc(sizeof(*taxSorted)*lines);
	for (size_t i = 0; i < lines; ++i) {
		ixSorted[i] = *Pointers[i];
		taxSorted[i] = taxList[Pointers[i] - ixList];
	}
	/*	for (size_t i = 0; i < lines; ++i) {
		fprintf(outfile,"%s=%s=%s\n",*Pointers[i],ixSorted[i],taxSorted[i]);
	}
	exit(2); */
	--lines; // lowerbound on search function is max index, not total no
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1);
	if (!doGG) while (++ns, line = fgets(line,LINELEN,fp)) {
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		size_t pre_ix = crBST(line+1,lines, ixSorted); 
		//printf("Tag is %s, which maps to %llu\n",line+1,pre_ix);
		if (pre_ix == -1) {puts("Error: taxon map incomplete"); exit(4);}
		IXTYPE ix = addSampleU(utree,taxSorted[pre_ix]);
		//printf("Tag is %s, which maps to %s, which is ix %llu\n",line+1,taxSorted[pre_ix],ix);
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		//continue;
		// add clumps and indices to tree
		int z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) UT_addWordIx(utree, word, ix);
		}
	}
	else while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		size_t pre_ix = crBST(line+1,lines, ixSorted); 
		//printf("Tag is %s, which maps to %llu\n",line+1,pre_ix);
		if (pre_ix == -1) {puts("Error: taxon map incomplete"); exit(4);}
		IXTYPE ix = addSampleU(utree,taxSorted[pre_ix]);
		//printf("Tag is %s, which maps to %s, which is ix %llu\n",line+1,taxSorted[pre_ix],ix);
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		//continue;
		// add clumps and indices to tree
		int z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) UT_addWordIxGG(utree, word, ix);
		}
	}
	fclose(fp); free(line); // purge buffers
	//exit(0);
	return ns-1; // number of sequences parsed
}

size_t UT_parseSampFastaExternMod(UTree *utree, char* filename, char* labels, int ixCol, int lblCol) {
	FILE *fp = fopen(filename, "rb"), *fp2 = fopen(labels, "rb");
	if (fp == 0 || fp2 == 0) { puts("Invalid input FASTA"); return 0; }
	// read in the second file
	fseek(fp2,0,SEEK_END); size_t filesz = ftell(fp2); rewind(fp2);
	char *dump = malloc(filesz+1); fread(dump,filesz,1,fp2); fclose(fp2);
	dump[filesz] = 0;
	size_t lines = 0;
	char *ptr = dump; do if (*ptr == '\n') ++lines; while (*++ptr);
	printf("Lines = %llu\n",lines); 
	char **lblList = malloc(sizeof(*lblList)*lines);
	char **ixList = malloc(sizeof(*ixList)*lines);
	FILE *outfile = fopen("outfile_temp_db.txt","wb");
	ptr = dump; // - 1; //while (*++ptr) {
	if (ixCol < lblCol) for (size_t i = 0; i < lines; ++i) {
		for (int j=0; j < ixCol; ++j) {
			while (*++ptr != '\t'); *ptr++ = 0; // skip to correct tab & nullify
		}
		ixList[i] = ptr; // store first string as key
		for (int j = 0; j < lblCol; ++j) {
			while (*++ptr != '\t'); *ptr++ = 0; // skip to correct tab & nullify
		}
		lblList[i] = ptr; // store second string as taxon
		while (*++ptr != '\n') if (*ptr=='\t') *ptr = 0; // get to end of line
		*ptr++ = 0; // replace newline with null
		//fprintf(outfile,"ix %s = %s\n",ixList[i],lblList[i]);
	}
	else for (size_t i = 0; i < lines; ++i) {
		for (int j=0; j < lblCol; ++j) {
			while (*++ptr != '\t'); *ptr++ = 0; // skip to correct tab & nullify
		}
		lblList[i] = ptr; // store first string as key
		for (int j = 0; j < ixCol; ++j) {
			while (*++ptr != '\t'); *ptr++ = 0; // skip to correct tab & nullify
		}
		ixList[i] = ptr; // store second string as taxon
		while (*++ptr != '\n') if (*ptr=='\t') *ptr = 0; // get to end of line
		*ptr++ = 0; // replace newline with null
		//fprintf(outfile,"ix %s = %s\n",ixList[i],lblList[i]);
	}
	//exit(1);
	// sorting by pointers is done here
	char ***Pointers = malloc(sizeof(*Pointers)*lines);
	for (size_t i = 0; i < lines; ++i) Pointers[i] = &ixList[i];
	qsort(Pointers,lines,sizeof(*Pointers),xcmpP);
	char **ixSorted = malloc(sizeof(*ixSorted)*lines),
		 **lblSorted = malloc(sizeof(*lblSorted)*lines);
	for (size_t i = 0; i < lines; ++i) {
		ixSorted[i] = *Pointers[i];
		lblSorted[i] = lblList[Pointers[i] - ixList];
	}
	/* for (size_t i = 0; i < lines; ++i) {
		fprintf(outfile,"%s=%s=%s\n",*Pointers[i],ixSorted[i],lblSorted[i]);
	}
	exit(2); */
	--lines; // lowerbound on search function is max index, not total no
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1);
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		size_t pre_ix = crBST(line+1,lines, ixSorted); 
		//fprintf(outfile,"Tag is %s, which maps to %llu\n",line+1,pre_ix);
		if (pre_ix == -1) {puts("Error: taxon map incomplete"); exit(4);}
		IXTYPE ix = addSampleU(utree,lblSorted[pre_ix]);
		//fprintf(outfile,"Tag is %s, which maps to %s, which is ix %u\n",line+1,lblSorted[pre_ix],ix);
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		//continue;
		// add clumps and indices to tree
		int z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) UT_addWordIx(utree, word, ix);
		}
	}
	fclose(fp); free(line); // purge buffers
	return ns-1; // number of sequences parsed
}

size_t UT_parseSampFastaExternOSFA(UTree *utree, char* filename, char* labels, 
int ixCol, int lblCol, int inc, int doGG) {
	FILE *fp = fopen(filename, "rb"), *fp2 = fopen(labels, "rb");
	if (fp == 0 || fp2 == 0) { puts("Invalid input FASTA"); return 0; }
	// read in the second file
	fseek(fp2,0,SEEK_END); size_t filesz = ftell(fp2); rewind(fp2);
	char *dump = malloc(filesz+1); fread(dump,filesz,1,fp2); fclose(fp2);
	dump[filesz] = 0;
	size_t lines = 0;
	char *ptr = dump; do if (*ptr == '\n') ++lines; while (*++ptr);
	//printf("Taxonomy labels (raw) = %llu\n",lines); 
	char **lblList = malloc(sizeof(*lblList)*lines);
	char **ixList = malloc(sizeof(*ixList)*lines);
	//FILE *outfile = fopen("outfile_temp_db.txt","wb");
	ptr = dump; 
	void (*addWord)(UTree *, WTYPE, IXTYPE) = doGG ? 
		&UT_addWordIxGG : &UT_addWordIx, (*screenWord)(UTree *, WordIxPair) =
		doGG ? &checkAndNullU_GG : &checkAndNullU; // dynamic recompilation
	if (ixCol < lblCol) for (size_t i = 0; i < lines; ++i) {
		for (int j=0; j < ixCol; ++j) {
			while (*++ptr != '\t'); *ptr++ = 0; // skip to correct tab & nullify
		}
		ixList[i] = ptr; // store first string as key
		for (int j = 0; j < lblCol; ++j) {
			while (*++ptr != '\t'); *ptr++ = 0; // skip to correct tab & nullify
		}
		lblList[i] = ptr; // store second string as taxon
		while (*++ptr != '\n') if (*ptr=='\t') *ptr = 0; // get to end of line
		*ptr++ = 0; // replace newline with null
	}
	else for (size_t i = 0; i < lines; ++i) {
		for (int j=0; j < lblCol; ++j) {
			while (*++ptr != '\t'); *ptr++ = 0; // skip to correct tab & nullify
		}
		lblList[i] = ptr; // store first string as key
		for (int j = 0; j < ixCol; ++j) {
			while (*++ptr != '\t'); *ptr++ = 0; // skip to correct tab & nullify
		}
		ixList[i] = ptr; // store second string as taxon
		while (*++ptr != '\n') if (*ptr=='\t') *ptr = 0; // get to end of line
		*ptr++ = 0; // replace newline with null
	}
	// sorting by pointers is done here
	char ***Pointers = malloc(sizeof(*Pointers)*lines);
	for (size_t i = 0; i < lines; ++i) Pointers[i] = &ixList[i];
	qsort(Pointers,lines,sizeof(*Pointers),xcmpP);
	char **ixSorted = malloc(sizeof(*ixSorted)*lines),
		 **lblSorted = malloc(sizeof(*lblSorted)*lines);
	for (size_t i = 0; i < lines; ++i) {
		ixSorted[i] = *Pointers[i];
		lblSorted[i] = lblList[Pointers[i] - ixList];
	}
	--lines; // lowerbound on search function is max index, not total no
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1), *origLine = line;
	//puts("Died."); exit(4);
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		size_t pre_ix = crBST(line+1,lines, ixSorted); 
		//fprintf(outfile,"Tag is %s, which maps to %llu\n",line+1,pre_ix);
		if (pre_ix == -1) {puts("Error: taxon map incomplete"); exit(4);}
		IXTYPE ix = addSampleU(utree,lblSorted[pre_ix]);
		//fprintf(outfile,"Tag is %s, which maps to %s, which is ix %u\n",line+1,lblSorted[pre_ix],ix);
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		//exit(3);
		//continue;
		// add clumps and indices to tree
		size_t z = 0, x = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, x=0,z=0; continue; }
			word <<=2u, word += motive;
			if (++x >= PACKSIZE && ++z == inc) z=0, addWord(utree, word, ix);
		}
		if (z) addWord(utree,word,ix);
	}
	if (inc == 1) 
		goto End;
	// Round 2: double-check and nullify
	rewind(fp);
	line = origLine;
	ns = 0;
	puts("Refining tree...");
	// Balance the tree to facilitate search
	#pragma omp parallel for
	for (size_t i = 0; i < KHASH_SIZE; ++i) {
		if (utree->NumsInserted[i] > 2) utree->Roots[i] = 
			simpleBalanceU(utree->Roots[i],utree->NumsInserted[i]);
		size_t tempThres = utree->NumsInserted[i] * 2;
		//if (tempThres > utree->BalanceThreshes[i])
		if (tempThres < 3) tempThres = UBAL_THRES;
			utree->BalanceThreshes[i] = tempThres;
	}
	
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		//IXTYPE ix = addSampleUd(utree,line+1); 
		size_t pre_ix = crBST(line+1,lines, ixSorted); 
		IXTYPE ix = addSampleUd(utree,lblSorted[pre_ix]);
		
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		
		// add clumps and indices to tree
		size_t z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) screenWord(utree, (WordIxPair){word,ix});
		}
	}
	doGG ? checkUmbrellaU_GG : checkUmbrellaU(utree); // clear backlog
	
End:
	fclose(fp); free(origLine); // purge buffers
	free(dump);
	return ns-1; // number of sequences parsed
}

//int wcpCompare
typedef struct WordCountPair WordCountPair;
struct WordCountPair {
	char *word;
	uint16_t count;
	WordCountPair *left, *right;
};
WordCountPair * WCP_insert(WordCountPair *tree, WordCountPair **wcp, char *string, uint16_t count) {
	if (!tree->count) {
		//printf("Creating root with name: %s, count: %u\n",string,count);
		*tree = (WordCountPair){string,count,0,0};
		return tree;
	}
	int cmp = strcmp(string,tree->word);
	//printf("-->Comparison of %s and %s is: %d\n",string,tree->word,cmp);
	do {
		if (cmp > 0) {
			if (!tree->right) {
				//printf("-->Creating right branch with name: %s, count: %u\n",string,count);
				tree->right = ++*wcp;
				*tree->right = (WordCountPair){string,count,0,0};
				return tree->right;
			}
			tree = tree->right;
		}
		else if (cmp < 0) {
			if (!tree->left) {
				//printf("-->Creating left branch with name: %s, count: %u\n",string,count);
				tree->left = ++*wcp;
				*tree->left = (WordCountPair){string,count,0,0};
				return tree->left;
			}
			tree = tree->left;
		}
	} while (cmp = strcmp(string,tree->word));
	//printf("-->Found existing node with name: %s, count: %u [+ %u]\n",tree->word,
	//	tree->count,count);
	tree->count += count;
	return tree;
}
// Code-name "Humpty_dumpty". Compile with -Wall
size_t UT_searchQueries(UTree *utree, char* filename, char* outfile, int doCollapse) {
	FILE *fp = fopen(filename, "rb"), *fpo = fopen(outfile, "wb");
	if (fp == NULL) { puts("Invalid input FASTA"); return 0; }
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1);  // ktree
	size_t goodFinds = 0;
	
	
	//char* AllTheKingsHorses[UINT16_MAX];
	
	static const int minLvl = 1, MAXLEN = 4096;
	int allTheKingsHorses = doCollapse + 1; // 7 levels + 1 for GG
	//IXTYPE Chariot[allTheKingsHorses][UINT16_MAX];
	IXTYPE **Chariot = malloc(sizeof(*Chariot)*allTheKingsHorses);
	if (doCollapse) for (int j = minLvl; j < allTheKingsHorses; ++j) 
		Chariot[j] = malloc(sizeof(*Chariot[j])*UINT16_MAX);
	unsigned *KingsMen = calloc(allTheKingsHorses,sizeof(*KingsMen));// = {0};
	//char humpty[4096] - {0};
	//uint8_t Hashes[196613] = {0};
	unsigned *Hashes = calloc(utree->sampIX+1,sizeof(*Hashes));
	IXTYPE UniqTaxa[utree->sampIX+1], UniqCounts[utree->sampIX+1];
	IXTYPE candidate = -1;
	//uint16_t LevelIX[allTheKingsHorses+1];
	//*LevelIX = 0, LevelIX[minLvl] = 0;
	
	// For no-/heuristic voting 
	IXTYPE AllTheKingsHorses[doCollapse? 1 : UINT16_MAX];
	int kingsMen = 0;
	#define INITIATE_WS() \
	while (++ns, line = fgets(line,LINELEN,fp)) { \
		char *src = line; \
		while (*++src && *src != ' ' && *src != '\n'); \
		line[src-line] = 0; \
		fprintf(fpo,"%s\t",line+1); /* print sample name */ \
		/* printf("SEQUENCE: %s\n",line+1);  */\
		if (!(line = fgets(line,LINELEN,fp))) /* get sequence k-mers */ \
			{ puts("Error reading file."); return 0; } \
		src = line; \
		register size_t length = strlen(src); \
		if (src[length-1] == '\n') --length; /* lop off newline(s) */ \
		if (src[length-1] == '\r') --length; /* supports every platform! */ \
		WTYPE word = 0; \
		size_t foundUniq = 0; \
		size_t maxSemis = 0; \
		char *maxTax = 0; 
	#define FINALIZE_WS() }
	#define WORD_SEARCH() \
	/* search for words in tree */ \
	size_t z = 0; for (size_t k = 0; k < length; ++k) { \
		WTYPE motive = *(C2Xb+*src++); \
		if (motive == 255) { word = 0, z=0; continue; } \
		word <<=2u, word += motive; \
		if (++z >= PACKSIZE) { \
			IXTYPE ix = UT_findIx(utree, word); \
			if (ix < EMPTY_IX) { \
				++foundUniq; \
				PREP_VOTE() \
				/* printf("  [%llu]-->%s\n",k,utree->SampStrings[ix]);  */\
			} \
		} \
	}
	// These are prototypes of the requisite PREP_VOTE
	#define FULLVOTE() \
		/* full vote: store full level information */ \
		int horse = utree->semicolons[ix]; \
		Chariot[horse][KingsMen[horse]++] = ix;
	#define EARLYTERMINATE() \
		/* For early termination, no voting */ \
		++goodFinds; \
		fprintf(fpo,"%s",utree->SampStrings[ix]); \
		break;
	#define HEURISTICVOTE() \
		/* heuristic vote: break ties at finest taxon */ \
		if (utree->semicolons[ix] > maxSemis) \
			maxSemis = utree->semicolons[ix], \
			kingsMen = 0, *AllTheKingsHorses = ix; \
		else if (utree->semicolons[ix] == maxSemis) \
			AllTheKingsHorses[++kingsMen] = ix;
	#define SHALLOWVOTE() \
		/* simple vote: max taxid wins */ \
			AllTheKingsHorses[kingsMen++] = ix;
	
	//INITIATE_WS()
	if (doCollapse == -1) {
		INITIATE_WS()
		#define PREP_VOTE() EARLYTERMINATE()
		WORD_SEARCH()
		#undef PREP_VOTE
		fprintf(fpo,"\n");
		FINALIZE_WS()
	}
	else if (!doCollapse) {
		INITIATE_WS()
		#define PREP_VOTE() SHALLOWVOTE()
		kingsMen = 0;
		WORD_SEARCH()
		#undef PREP_VOTE
		if (foundUniq) { // voting system, ultrafast
			++goodFinds;
			if (!kingsMen++) fprintf(fpo,"%s",utree->SampStrings[*AllTheKingsHorses]);
			else {
				for (int i = 0; i < kingsMen; ++i)
					//++Hashes[(size_t)AllTheKingsHorses[i] % 196613];
					++Hashes[AllTheKingsHorses[i]];
				int most = 0;
				for (int i = 0; i < kingsMen; ++i) {
					if (Hashes[AllTheKingsHorses[i]] > most) 
						most = Hashes[AllTheKingsHorses[i]],
						maxTax = utree->SampStrings[AllTheKingsHorses[i]];
					Hashes[AllTheKingsHorses[i]] = 0;
				}
				if (most < 2) --goodFinds;
				else fprintf(fpo,"%s",maxTax);
			}
		}
		fprintf(fpo,"\n");
		FINALIZE_WS()
	}
	else {
		INITIATE_WS()
		#define PREP_VOTE() FULLVOTE()
		WORD_SEARCH()
		#undef PREP_VOTE
		if (foundUniq) {
			//printf("K-mers found = %u\n",foundUniq);
			++goodFinds;
			// assign each unique pointer to a string
			int uix = 0; //, numUniq = 0;
			for (int txLvl=minLvl; txLvl < allTheKingsHorses; ++txLvl) {
				//printf("Taxonomy level: %d",txLvl);
				if (!KingsMen[txLvl]) { //puts(" (empty)"); 
					//LevelIX[txLvl+1] = uix; 
					continue; }
				//puts("");
				IXTYPE *Taxa = Chariot[txLvl];
				for (int i = 0; i < KingsMen[txLvl]; ++i) {
					++Hashes[Taxa[i]];
					//printf("  %u: taxid = %d (%s), hash_count = %d\n",i,
					//	Taxa[i],utree->SampStrings[Taxa[i]],Hashes[Taxa[i]]);
				}
				//printf("Number of unique classifications: %d\n",numUniq);
				for (int i = 0; i < KingsMen[txLvl]; ++i) {
					if (Hashes[Taxa[i]]) { // do whatever n times, reset count to 0
						UniqTaxa[uix] = Taxa[i]; 
						UniqCounts[uix++] = Hashes[Taxa[i]];
					}
						//chariotIX = Taxa[i]; 
					Hashes[Taxa[i]] = 0;
				}
				//LevelIX[txLvl+1] = uix;
				//printf("Number of unique: %d [bin ix: %u]\n",uix,LevelIX[txLvl]);
			}
			
			char Prefix[(uix+1) * MAXLEN], Excluded[uix];
			char *AllStrings[uix]; // *OldStrings[uix];
			for (int i=0; i < uix; ++i) {
				Excluded[i] = 0;
				AllStrings[i] = Prefix + i*MAXLEN;
				strcpy(AllStrings[i], utree->SampStrings[UniqTaxa[i]]);
				//printf("Uniq %d: %s [%u]\n",i,AllStrings[i],UniqCounts[i]);
			}
			
			WordCountPair WordsAndCounts[uix];
			WordCountPair *ReserveBins[uix];
			for (int i = 1; i < allTheKingsHorses; ++i) {
				WordCountPair *WCptr = WordsAndCounts; 
				*WordsAndCounts = (WordCountPair){0,0,0,0};
				for (int j = 0; j < uix; ++j) {
					if (Excluded[j]) continue;
					// for all active strings, advance pointer to next semicolon
					char *oldString = AllStrings[j];
					for (int semis = 0; !semis && *AllStrings[j];) 
						if (*AllStrings[j]++==';') ++semis, *(AllStrings[j]-1) = 0;
					//printf("String %d before %d semis: %s\n",j,i,OldStrings[j]);
					if (*AllStrings[j]==' ') ++AllStrings[j];
					if (oldString[3]) ReserveBins[j] = 
						WCP_insert(WordsAndCounts,&WCptr,oldString,UniqCounts[j]);
					else ReserveBins[j] = 0;
				}
				WordCountPair *ptr2 = WordsAndCounts;
				unsigned max = 0; 
				WordCountPair *MaxBin = 0;
				while (ptr2 <= WCptr) {
					//printf("Node %u: name: %s, count: %u\n",WCptr-ptr2,ptr2->word,ptr2->count);
					if (ptr2->count > max) max = ptr2->count, MaxBin = ptr2;
					++ptr2;
				}
				//printf("The max is %u\n",max);
				if (!max) break; 
				for (int j = 0; j < uix; ++j) {
					if (Excluded[j] || !ReserveBins[j]) {
						//printf("%s already excluded!\n",utree->SampStrings[UniqTaxa[j]]);
						continue;
					}
					if (ReserveBins[j]->count != max) //printf("Excluding %s\n",utree->SampStrings[UniqTaxa[j]]),
						Excluded[j]=1;
					else candidate = UniqTaxa[j];
				}
				//printf("Current candidate taxon: %s\n",utree->SampStrings[candidate]);
			}
			fprintf(fpo,"%s",utree->SampStrings[candidate]);
		}
		fprintf(fpo,"\n");
		for (int i = 0; i < allTheKingsHorses; ++i) KingsMen[i] = 0;
		FINALIZE_WS()
	}
	//FINALIZE_WS()
		
	fclose(fp); fclose(fpo); free(line); // purge buffers
	free(Hashes); free(KingsMen);
	printf("Good finds: %llu\n",goodFinds);
	return ns-1; // number of sequences parsed
}

// Define search decompression macros 
#define ADDR_AT(raw,i) ((raw) + SZ*(i))
#define WORD_AT(raw,i,pre) ((*(WTYPE*)ADDR_AT(raw,i) & MASK) | pre)
#define SUFFIX_AT(raw,i) (*(WTYPE*)ADDR_AT(raw,i) & MASK)
#define IX_AT(raw,i) *(IXTYPE*)(ADDR_AT(raw,i)+CMPWDSZ)

#define FIRST_WORD(raw,pre) ((*(WTYPE*)(raw) & MASK) | pre)
#define FIRST_SUFFIX(raw) (*(WTYPE*)(raw) & MASK)
#define FIRST_IX(raw) *(IXTYPE*)((raw)+CMPWDSZ)
#define IXDIST(raw,new) ((new)-(raw))/SZ
#define PREFIX(word) (word & PMASK)
#define PREFIX_L(word) (word >> SXBITS)
#define SUFFIX(word) (word & MASK)
#define PREFIX_AT32(ix,BinIx) ((WTYPE)uWBS32(BinIx,ix,0,BINRANGE) << SXBITS)

// Define search compression constants
#define CMP 3
#define PXBITS (CMP * 8)
const int SZ= sizeof(WTYPE) + sizeof(IXTYPE) - CMP, 
	CMPWDSZ = sizeof(WTYPE) - CMP;
const unsigned int NUMBINS = (1 << PXBITS) + 1;
const int SXBITS = PACKSIZE*2 - PXBITS;
const size_t BINRANGE = 1 << PXBITS;

WTYPE MASK = 0, PMASK = 0;
//uint32_t *BINIX32 = 0;
//uint32_t *BINIX64 = 0;

inline char * xtSuffixBS( char array[], size_t size, WTYPE sx) {
	char *p=array;
	while (size) {
		size_t w = size >> 1;
		if (SUFFIX_AT(p,w+1) <= sx) p+=(w+1)*SZ, size-=w+1; 
		else size =w;
	}
	return FIRST_SUFFIX(p)==sx ? p : 0;
}

inline uint32_t uWBS32(uint32_t *ixList, uint32_t key, uint32_t low, uint32_t high) {
	uint32_t middle; //, low = 0, high = range;
	while (low < high) {
		middle = low + ((high - low) >> 1);
		if (key > ixList[middle]) low = middle + 1;
		else high = middle;
	}
	if (ixList[low] > key) --low;
	return low;
}

inline IXTYPE XT_getIX32(UTree *utree, WTYPE word) {
	uint32_t *BinIx = utree->BinIx;
	WTYPE qprefix = PREFIX_L(word), qsuff = SUFFIX(word);
	size_t start_i = BinIx[qprefix], end_i = BinIx[qprefix+1];
	if (start_i == end_i) return BAD_IX;
	
	char *found = xtSuffixBS(ADDR_AT(utree->Dump,start_i), end_i-start_i-1, qsuff);
	return found ? FIRST_IX(found) : BAD_IX;
}

int readSamplesFPdelim(UTree *ktree, FILE *fp, char delim);
UTree *XT_read32(char *db) {
	FILE *dp = fopen(db,"rb");
	if (!dp) { puts("Invalid DB file"); exit(0); }
	uint64_t metadata[4] = {0};
	size_t numRead = fread(metadata, sizeof(*metadata), 4, dp);
	if (numRead < 4 || !metadata[3]) {puts("Tree malformatted."); exit(0); }
	// Check file for compatibility with this compilation config
	#ifdef NO_COUNT
		#define CNT_SIZE 0
	#else
		#define CNT_SIZE sizeof(CNTTYPE)
	#endif
	uint64_t numNodes = metadata[3]; 
	if (metadata[0] != sizeof(WTYPE) || metadata[1] != CNT_SIZE ||
		metadata[2] != sizeof(IXTYPE)) {
			printf("ERROR. Input tree requires PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s\n", 
				metadata[0] << 2,TYPEARR[metadata[1]], TYPEARR[metadata[2]]);
		exit(0);
	}
	// Prepare the bin delimiters 
	// See constants declared above
	if (numNodes < UINT32_MAX) puts("Using 32-bit counters");
	uint32_t *BinIx = malloc(NUMBINS*sizeof(*BinIx));
	numRead = fread(BinIx, sizeof *BinIx,NUMBINS,dp);
	printf("%llu elements read.\n",numRead);
	
	// Read in the tree
	printf("Nodes in input tree: %llu (PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s, SZ=%d)\n",
		numNodes, metadata[0] << 2, TYPEARR[metadata[1]], TYPEARR[metadata[2]],SZ);
	char *Dump = malloc(numNodes * SZ + sizeof(WTYPE)); // add extra WTYPE buffer on end
	numRead = fread(Dump, SZ, numNodes, dp);
	if (numRead != numNodes) {puts("Error in reading tree."); exit(3);}
	printf("Read %llu nodes.\n",numRead);
	
	// Prepare annotation
	UTree *utree = calloc(1,sizeof *utree);
	utree->sampStringSz = 10;
	int annotated = readSamplesFPdelim(utree, dp, 0);
	if (!annotated) puts("No annotation found in tree file."); 
	fclose(dp);
	
	// ATCGGAAAGAATCCCT
	char *cmask = malloc(sizeof(WTYPE)); //, *cpmask = malloc(sizeof(WTYPE));
	for (int i = 0; i < CMPWDSZ; ++i) cmask[i] = 0xff;
	for (int i = CMPWDSZ; i < sizeof(WTYPE); ++i) cmask[i] = 0x00;
	MASK = *(WTYPE*)cmask, PMASK = ~MASK; // register ? const ?
	
	// try on a test word
	/* WTYPE wordOfInterest = WORD_AT(Dump,27982215,PREFIX_AT32(27982215,BinIx));
	printf("Word ix 27982215 is: %s [%llu], tax %llu\n",KT_num2word(wordOfInterest),
		(uint64_t)wordOfInterest,IX_AT(Dump,27982215));
	
	WTYPE qprefix = PREFIX_L(wordOfInterest), qsuff = SUFFIX(wordOfInterest);
	size_t start_i = BinIx[qprefix], end_i = BinIx[qprefix+1];
	printf("start_i = %u, end_i = %u\n",start_i, end_i);
	if (start_i == end_i) puts("This aint gonna work."); 
	else { 
		char *found = xtSuffixBS(ADDR_AT(Dump,start_i), end_i-start_i-1, qsuff);
		printf("Found? %d At: %llu of taxon: %u \n",found, IXDIST(Dump, found), FIRST_IX(found));
	} */

	// Save in tree object
	initConverter();
	utree->Dump = Dump;
	utree->BinIx = BinIx;
	return utree;
}

size_t XT_doSearch32(UTree *utree, char* filename, char* outfile, int doCollapse) {
	FILE *fp = fopen(filename, "rb"), *fpo = fopen(outfile, "wb");
	if (fp == NULL) { puts("Invalid input FASTA"); return 0; }
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1);  // ktree
	size_t goodFinds = 0;
	
	// Cache important variables
	char *Dump = utree->Dump;
	uint32_t *BinIx = utree->BinIx;
	IXTYPE maxIX = utree->sampIX + 1;
	char **SampStrings = utree->SampStrings;
	uint8_t *semicolons = utree->semicolons;
	
	static const int minLvl = 1, MAXLEN = 4096;
	int allTheKingsHorses = doCollapse + 1; // 7 levels + 1 for GG
	//IXTYPE Chariot[allTheKingsHorses][UINT16_MAX];
	IXTYPE **Chariot = malloc(sizeof(*Chariot)*allTheKingsHorses);
	if (doCollapse) for (int j = minLvl; j < allTheKingsHorses; ++j) 
		Chariot[j] = malloc(sizeof(*Chariot[j])*UINT16_MAX);
	unsigned *KingsMen = calloc(allTheKingsHorses,sizeof(*KingsMen));// = {0};
	//char humpty[4096] - {0};
	//uint8_t Hashes[196613] = {0};
	unsigned *Hashes = calloc(maxIX,sizeof(*Hashes));
	IXTYPE UniqTaxa[maxIX], UniqCounts[maxIX];
	IXTYPE candidate = -1;
	
	// For no-/heuristic voting 
	IXTYPE AllTheKingsHorses[doCollapse? 1 : UINT16_MAX];
	int kingsMen = 0;
	#define XT_INITIATE_WS() \
	while (++ns, line = fgets(line,LINELEN,fp)) { \
		char *src = line; \
		while (*++src && *src != ' ' && *src != '\n'); \
		line[src-line] = 0; \
		fprintf(fpo,"%s\t",line+1); /* print sample name */ \
		/* printf("SEQUENCE: %s\n",line+1);  */\
		if (!(line = fgets(line,LINELEN,fp))) /* get sequence k-mers */ \
			{ puts("Error reading file."); return 0; } \
		src = line; \
		register size_t length = strlen(src); \
		if (src[length-1] == '\n') --length; /* lop off newline(s) */ \
		if (src[length-1] == '\r') --length; /* supports every platform! */ \
		WTYPE word = 0; \
		size_t foundUniq = 0; \
		size_t maxSemis = 0; \
		char *maxTax = 0; \
		size_t nextValid = PACKSIZE;
	#define XT_FINALIZE_WS() }
	#define XT_WORD_SEARCH() \
	/* search for words in tree */ \
	size_t z = 0; for (size_t k = 0; k < length; ++k) { \
		WTYPE motive = *(C2Xb+*src++); \
		if (motive == 255) { word = 0, z=0, nextValid = PACKSIZE; continue; } \
		word <<=2u, word += motive; \
		if (++z >= PACKSIZE) { \
			IXTYPE ix = XT_getIX32(utree, word); \
			if (ix < EMPTY_IX) { \
				++foundUniq; \
				XT_PREP_VOTE() \
				/* printf("  [%llu]-->%s\n",k,SampStrings[ix]);  */\
			} \
		} \
	}
	// These are prototypes of the requisite XT_PREP_VOTE
	#define XT_FULLVOTE() \
		/* full vote: store full level information */ \
		int horse = semicolons[ix]; \
		Chariot[horse][KingsMen[horse]++] = ix;
	#define XT_EARLYTERMINATE() \
		/* For early termination, no voting */ \
		++goodFinds; \
		fprintf(fpo,"%s",SampStrings[ix]); \
		break;
	#define XT_HEURISTICVOTE() \
		/* heuristic vote: break ties at finest taxon */ \
		if (semicolons[ix] > maxSemis) \
			maxSemis = semicolons[ix], \
			kingsMen = 0, *AllTheKingsHorses = ix; \
		else if (semicolons[ix] == maxSemis) \
			AllTheKingsHorses[++kingsMen] = ix;
	#define XT_SHALLOWVOTE() \
		/* simple vote: max taxid wins */ \
		if (z >= nextValid) nextValid = z + PACKSIZE/SPARSITY,  \
			AllTheKingsHorses[kingsMen++] = ix;
	#ifndef TOLERANCE_THRESHOLD
		#define TOLERANCE_THRESHOLD 2
	#endif
	#ifndef SLACK
		#define SLACK 3
	#endif
	#ifndef SPARSITY
		#define SPARSITY 4
	#endif
	//XT_INITIATE_WS()
	if (doCollapse == -1) {
		XT_INITIATE_WS()
		#define XT_PREP_VOTE() XT_EARLYTERMINATE()
		XT_WORD_SEARCH()
		#undef XT_PREP_VOTE
		fprintf(fpo,"\n");
		XT_FINALIZE_WS()
	}
	else if (!doCollapse) {
		XT_INITIATE_WS()
		#define XT_PREP_VOTE() XT_SHALLOWVOTE()
		kingsMen = 0;
		XT_WORD_SEARCH()
		#undef XT_PREP_VOTE
		if (foundUniq) { // voting system, ultrafast
			++goodFinds;
			if (!kingsMen++) fprintf(fpo,"%s",SampStrings[*AllTheKingsHorses]);
			else {
				for (int i = 0; i < kingsMen; ++i)
					//++Hashes[(size_t)AllTheKingsHorses[i] % 196613];
					++Hashes[AllTheKingsHorses[i]];
				int most = 0, secondMost = 0;
				IXTYPE mostIX, secondMostIX = BAD_IX;
				for (int i = 0; i < kingsMen; ++i) {
					if (Hashes[AllTheKingsHorses[i]] > most)
						secondMost = most, secondMostIX = mostIX,
						mostIX = AllTheKingsHorses[i],
						most = Hashes[AllTheKingsHorses[i]];
					else if (Hashes[AllTheKingsHorses[i]] > secondMost)
						secondMostIX = AllTheKingsHorses[i],
						secondMost = Hashes[secondMostIX];
					Hashes[AllTheKingsHorses[i]] = 0;
				}
				/* if ( most < TOLERANCE_THRESHOLD || (secondMost && secondMost > most - SLACK 
					&& secondMostIX != mostIX) ) --goodFinds; */
				if ( most < TOLERANCE_THRESHOLD || most < SLACK*secondMost) --goodFinds;
				else 
					fprintf(fpo,"%s",SampStrings[mostIX]);
			}
		}
		fprintf(fpo,"\n");
		XT_FINALIZE_WS()
	}
	else {
		XT_INITIATE_WS()
		#define XT_PREP_VOTE() XT_FULLVOTE()
		XT_WORD_SEARCH()
		#undef XT_PREP_VOTE
		if (foundUniq) {
			//printf("K-mers found = %u\n",foundUniq);
			++goodFinds;
			// assign each unique pointer to a string
			int uix = 0; //, numUniq = 0;
			for (int txLvl=minLvl; txLvl < allTheKingsHorses; ++txLvl) {
				//printf("Taxonomy level: %d",txLvl);
				if (!KingsMen[txLvl]) { //puts(" (empty)"); 
					//LevelIX[txLvl+1] = uix; 
					continue; }
				//puts("");
				IXTYPE *Taxa = Chariot[txLvl];
				for (int i = 0; i < KingsMen[txLvl]; ++i) {
					++Hashes[Taxa[i]];
					//printf("  %u: taxid = %d (%s), hash_count = %d\n",i,
					//	Taxa[i],SampStrings[Taxa[i]],Hashes[Taxa[i]]);
				}
				//printf("Number of unique classifications: %d\n",numUniq);
				for (int i = 0; i < KingsMen[txLvl]; ++i) {
					if (Hashes[Taxa[i]]) { // do whatever n times, reset count to 0
						UniqTaxa[uix] = Taxa[i]; 
						UniqCounts[uix++] = Hashes[Taxa[i]];
					}
						//chariotIX = Taxa[i]; 
					Hashes[Taxa[i]] = 0;
				}
				//LevelIX[txLvl+1] = uix;
				//printf("Number of unique: %d [bin ix: %u]\n",uix,LevelIX[txLvl]);
			}
			
			char Prefix[(uix+1) * MAXLEN], Excluded[uix];
			char *AllStrings[uix]; // *OldStrings[uix];
			for (int i=0; i < uix; ++i) {
				Excluded[i] = 0;
				AllStrings[i] = Prefix + i*MAXLEN;
				strcpy(AllStrings[i], SampStrings[UniqTaxa[i]]);
				//printf("Uniq %d: %s [%u]\n",i,AllStrings[i],UniqCounts[i]);
			} 
			
			WordCountPair WordsAndCounts[uix];
			WordCountPair *ReserveBins[uix];
			for (int i = 1; i < allTheKingsHorses; ++i) {
				WordCountPair *WCptr = WordsAndCounts; 
				*WordsAndCounts = (WordCountPair){0,0,0,0};
				for (int j = 0; j < uix; ++j) {
					if (Excluded[j]) continue;
					// for all active strings, advance pointer to next semicolon
					char *oldString = AllStrings[j];
					for (int semis = 0; !semis && *AllStrings[j];) 
						if (*AllStrings[j]++==';') ++semis, *(AllStrings[j]-1) = 0;
					//printf("String %d before %d semis: %s\n",j,i,OldStrings[j]);
					if (*AllStrings[j]==' ') ++AllStrings[j];
					if (oldString[3]) ReserveBins[j] = 
						WCP_insert(WordsAndCounts,&WCptr,oldString,UniqCounts[j]);
					else ReserveBins[j] = 0;
				}
				WordCountPair *ptr2 = WordsAndCounts;
				unsigned max = 0; 
				WordCountPair *MaxBin = 0;
				while (ptr2 <= WCptr) {
					//printf("Node %u: name: %s, count: %u\n",WCptr-ptr2,ptr2->word,ptr2->count);
					if (ptr2->count > max) max = ptr2->count, MaxBin = ptr2;
					++ptr2;
				}
				//printf("The max is %u\n",max);
				if (!max) break; 
				for (int j = 0; j < uix; ++j) {
					if (Excluded[j] || !ReserveBins[j]) {
						//printf("%s already excluded!\n",SampStrings[UniqTaxa[j]]);
						continue;
					}
					if (ReserveBins[j]->count != max) //printf("Excluding %s\n",SampStrings[UniqTaxa[j]]),
						Excluded[j]=1;
					else candidate = UniqTaxa[j];
				}
				//printf("Current candidate taxon: %s\n",SampStrings[candidate]);
			}
			fprintf(fpo,"%s",SampStrings[candidate]);
		}
		fprintf(fpo,"\n");
		for (int i = 0; i < allTheKingsHorses; ++i) KingsMen[i] = 0;
		XT_FINALIZE_WS()
	}
	//XT_FINALIZE_WS()
	fclose(fp); fclose(fpo); free(line); // purge buffers
	free(Hashes); free(KingsMen);
	printf("Good finds: %llu\n",goodFinds);
	return ns-1; // number of sequences parsed
}

size_t UT_parseSampFastaSparse(UTree *utree, char* filename, int speed, int sparsify) {
	FILE *fp = fopen(filename, "rb");
	if (fp == NULL) { puts("Invalid input FASTA"); return 0; }
	//int rigor = 0; if (!speed) speed = 1, rigor = 1;
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1), *origLine = line;  // ktree
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSampleU(utree,line+1);
		
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		
		// add clumps and indices to tree
		size_t z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z == PACKSIZE) z=0, UT_addWordIx(utree, word, ix);
		}
		if (z) UT_addWordIx(utree, word, ix);
	}
	// round 2: check up on it!
	rewind(fp);
	line = origLine;
	ns = 0;
	/* size_t balBufSz = 0;
	#pragma omp parallel for reduction(max:balBufSz)
	for (size_t i = 0; i < KHASH_SIZE; ++i)
		if (utree->NumsInserted[i] > balBufSz) 
			balBufSz = utree->NumsInserted[i];
	if (balBufSz < 65536)  
		balBufSz = 65536; 
	KMerY **BalBuf = malloc(balBufSz*sizeof(*BalBuf)); */
	
	// Balance the tree to facilitate search
	#pragma omp parallel for
	for (size_t i = 0; i < KHASH_SIZE; ++i) {
		if (utree->NumsInserted[i] > 2) utree->Roots[i] = 
			simpleBalanceU(utree->Roots[i],utree->NumsInserted[i]);
		size_t tempThres = utree->NumsInserted[i] * 2;
		//if (tempThres > utree->BalanceThreshes[i])
		if (tempThres < 3) tempThres = UBAL_THRES;
			utree->BalanceThreshes[i] = tempThres;
	}
	
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSampleUd(utree,line+1); 
		
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		
		// add clumps and indices to tree
		size_t z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) checkAndNullU(utree, (WordIxPair){word,ix});
		}
	}
	checkUmbrellaU(utree); // clear backlog
	//printf("Pruned %llu additional nodes in phase 1 (of %llu, %f%%).\n",PRUNED,
	//	(uint64_t)*utree->NumsInserted, (double)PRUNED / *utree->NumsInserted * 100.f); 
	if (!speed) goto Finish;
	PRUNED = 0;
	
	// Round 3: parapluie add and modify
	rewind(fp);
	line = origLine;
	ns = 0; 
	//#pragma omp parallel for
	//for (size_t i = 0; i < KHASH_SIZE; ++i)
	//	utree->BalanceThreshes[i] = 1.333*utree->BalanceThreshes[i];
	while (++ns, line = fgets(line,LINELEN,fp)) { 
	char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSampleUd(utree,line+1); 
		
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		
		// add clumps and indices to tree
		WTYPE Wordbank[PACKSIZE];
		int wbix = 0, ready = 0; // can overlap and go nuts
		long z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0, ready=0; continue; }
			word <<=2u, word += motive;
			Wordbank[wbix] = word;
			
			if (++z >= PACKSIZE) {
				//PFTYPE prefix = word >> ((PACKSIZE << 1) - PFBITS);
				//STYPE suffix = (word << PFBITS) >> PFBITS;
				int x = parapluieU(utree, word, ix); 
				if (x && ready) { // search backwards by ready-1 points
					//int limit = PACKSIZE < ready ? PACKSIZE : ready;
					int tempWBIX = wbix, tb = 0;
					for (; tb < ready; ++tb) { 
						if (--wbix < 0) wbix = PACKSIZE - 1;
						int c = parapluieU(utree, Wordbank[wbix], ix);
						if (!c) {z = tb; break;}
					}
					ready = PACKSIZE/speed - tb;
					wbix = tempWBIX;
				} 
				else if (!x) z=0, ready=PACKSIZE/speed; // how far back we can uniquely go
				else if (z - PACKSIZE == PACKSIZE/speed) 
					z = PACKSIZE/speed, ready = PACKSIZE/speed;
				//if (ns==289) printf("%llu ",z);
				/* if (utree->NumsInserted[prefix] >= utree->BalanceThreshes[prefix]) {
					//utree->Roots[prefix] = balanceTreeU(utree->Roots[prefix],
						//utree->NumsInserted[prefix], utree->TotalCounts[prefix]);
					if (utree->NumsInserted[prefix] < BALBUFSZ)
						utree->Roots[prefix] = simpleBalanceUX(utree->Roots[prefix],
							utree->NumsInserted[prefix],BALBUF);
					else utree->Roots[prefix] = simpleBalanceU(utree->Roots[prefix],
						utree->NumsInserted[prefix]);
					utree->BalanceThreshes[prefix] *= 2;
				} */
			}
			if (++wbix == PACKSIZE) wbix = 0;
		}
		
	}
	// Round 4: re-validation (with incrementing!)
	#pragma omp parallel for
	for (size_t i = 0; i < KHASH_SIZE; ++i)
		utree->Roots[i] = simpleBalancePurgeU(utree->Roots[i],
		&utree->NumsInserted[i],&utree->TotalCounts[i]);
	rewind(fp);
	line = origLine;
	ns = 0;
	//avWeight = (double)*ktree->TotalCounts / *ktree->NumsInserted;
	//bigNode = (*ktree->Roots)->count;
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSampleUd(utree,line+1); 
		
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		
		// add clumps and indices to tree
		size_t z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) checkAndNullUx(utree, (WordIxPair){word,ix});
		}
	}
	checkUmbrellaUx(utree); // clear backlog
	if (!sparsify) goto Finish;
#ifndef NO_COUNT
	// Round 5: pruning
	rewind(fp);
	line = origLine;
	ns = 0;
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSampleUd(utree,line+1); 
		
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		//printf("%llu\n",ns);
		// wrangle the clumps; trim the fat
		//int rollingSz = PACKSIZE + 1;
		KMerY * kmers[PACKSIZE+1], *lastGoodKmer = 0, *thisGoodKmer = 0; 
		int z=0, y = 0, numGood = 0, filled = 0;
		for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) {
				if (++filled > (PACKSIZE+1)) { //rolling starts on the 33rd letter
					if (y == PACKSIZE+1) y = 0;
					if (kmers[y]->ix != BAD_IX) --numGood;
				}
				KMerY *kmer = getNodeU(utree,word);
				kmers[y] = kmer; 
				
				if (kmer->ix != BAD_IX) {
					++numGood;
					lastGoodKmer = thisGoodKmer;
					thisGoodKmer = kmer;
				}
				//printf("%d ",kmer->ix!=BAD_IX);
				// too frequent: possibility of accidentally pruning elsewhere
				if (numGood > 2 && lastGoodKmer->count < 3) 
						lastGoodKmer->ix = BAD_IX, --numGood; 
				++y; 
			}
		}
		//printf("\n");
		/* z=0; src=line; word = 0;
		for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) { word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) printf("%d ", (getNodeU(utree,word))->ix != BAD_IX);
		}
		printf("\n"); */
		// endpiece: if over 1 good in last block, discard all after first
	}
#endif
Finish:
	fclose(fp); free(origLine); // purge buffers
	//free(BalBuf);
	size_t tot = 0, nodes = 0;
	#pragma omp parallel for reduction(+:tot) reduction(+:nodes)
	for (size_t i = 0; i < KHASH_SIZE; ++i)
		tot += utree->TotalCounts[i], nodes+= utree->NumsInserted[i];
	utree->numInserted = nodes;
	utree->totalCount = tot;
	printf("Total nodes = %llu, total count = %llu\n",nodes,tot);
	return ns-1; // number of sequences parsed
}


size_t KT_parseSampFastaSparse(KTree *ktree, char* filename, unsigned speed) {
	FILE *fp = fopen(filename, "rb");
	if (fp == NULL) { puts("Invalid input FASTA"); return 0; }
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1), *origLine = line; 
	ktree->synced = 0;
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix;
		if (!ktree->Samps) {
			ktree->Samps = malloc(sizeof(*ktree->Samps));
			char *str = malloc(strlen(line));
			strcpy(str,line+1);
			*ktree->Samps = (SampX){str,ix=0,0,0};
			ktree->SampStrings = malloc(sizeof(*ktree->SampStrings)*ktree->sampStringSz);
			*ktree->SampStrings = str;
		}
		else ix = addSample(ktree,line+1);
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		// add clumps and indices to tree
		int z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) {word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z == PACKSIZE) z = 0, KT_addWordIx(ktree, word, ix);
		}
		// get tailpiece
		if (z) KT_addWordIx(ktree,word,ix);
	}
	
	// round 2
	KT_sync(ktree);
	rewind(fp);
	line = origLine;
	ns = 0;
	double avWeight = (double)*ktree->TotalCounts / *ktree->NumsInserted;
	size_t bigNode = (*ktree->Roots)->count;
	//printf("avWeight=%f, big weight=%llu\n",avWeight,bigNode);
	/* if (bigNode < 16*avWeight) 
		{puts("Sparse node detected 1.5.");} */
	*ktree->Roots = simpleBalance(*ktree->Roots,*ktree->NumsInserted);
	//KMerX **array = createArrayP(*ktree->Roots,*ktree->NumsInserted);
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		//printf("...NS: %llu\n",ns);
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSample(ktree,line+1); // we know it exits
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		
		// add clumps and indices to tree
		WTYPE word = 0;
		size_t z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) {word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) 
				checkParallel_noBal(ktree, word, ix);
				//checkBinaryP(ktree, array, word, ix);
		}
	}
	//printf("clearing backlog of %llu items...\n",ktree->queuedClumps);
	checkUmbrella_noBal(ktree); // clear the backlog
	printf("Pruned %llu additional nodes in phase 1 (of %llu, %f%%).\n",PRUNED,
		(uint64_t)*ktree->NumsInserted, (double)PRUNED / *ktree->NumsInserted * 100.f); 
	//fireCheckArrayP(ktree,array); free(array);
	if (!speed) goto Finish;
	PRUNED = 0;
	
	// Round 3: parapluie add and modify
	rewind(fp);
	line = origLine;
	ns = 0; 
	*ktree->BalanceThreshes = 1.333**ktree->NumsInserted;
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		//printf("...NS: %llu\n",ns);
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSample(ktree,line+1); // we know it exits
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = 0;
		
		// add clumps and indices to tree
		size_t N;
		unsigned z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) {word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) {
				z = parapluie(ktree, word, ix, z, speed);
				//if (unique) z = 0; // it's there and unique 
				if (*ktree->NumsInserted >= *ktree->BalanceThreshes) { 
					//printf("Balancing tree at %lu\n",*ktree->NumsInserted); 
					*ktree->Roots = balanceTree(*ktree->Roots,*ktree->NumsInserted-1, 
						*ktree->TotalCounts); 
					//KT_simpleBalancePurge(ktree);
					*ktree->BalanceThreshes=1.333**ktree->BalanceThreshes; 
				}
			}
		}
	}
	// round 4 validation, again
	KT_sync(ktree);
	rewind(fp);
	line = origLine;
	ns = 0;
	avWeight = (double)*ktree->TotalCounts / *ktree->NumsInserted;
	bigNode = (*ktree->Roots)->count;
	//printf("avWeight=%f, big weight=%llu\n",avWeight,bigNode);
	if (bigNode < 16*avWeight) KT_simpleBalancePurge(ktree);
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		//printf("...NS: %llu\n",ns);
		char *src = line + 1; // sample name parsed to generate ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); 
		IXTYPE ix = addSample(ktree,line+1); // we know it exits
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		
		// add clumps and indices to tree
		WTYPE word = 0;
		size_t z = 0; for (int k = 0; k < length; ++k) {
			WTYPE motive = *(C2Xb+*src++);
			if (motive == 255) {word = 0, z=0; continue; }
			word <<=2u, word += motive;
			if (++z >= PACKSIZE) 
				checkParallel_noBal(ktree, word, ix);
		}
	}
	//printf("invalidated nodes = %llu\n",N);
	//printf("clearing backlog of %llu items...\n",ktree->queuedClumps);
	checkUmbrella_noBal(ktree); // clear the backlog
	printf("Pruned %llu additional nodes in phase 3 (of %llu, %f%%).\n",PRUNED,
		(uint64_t)*ktree->NumsInserted, (double)PRUNED / *ktree->NumsInserted * 100.f); 
Finish:
	fclose(fp); free(origLine); // purge buffers
	ktree->numInserted = *ktree->NumsInserted;
	ktree->totalCount = *ktree->TotalCounts;
	return ns-1; // number of sequences parsed
}

size_t KT_parseIxFasta(KTree *ktree, char* filename) {
	FILE *fp = fopen(filename, "rb");
	if (fp == NULL) { puts("Invalid input FASTA"); return 0; }
	ktree->synced = 0;
	size_t ns=0, LINELEN = 10000000; // 10MB lines
	char *line = malloc(LINELEN + 1); 
	while (++ns, line = fgets(line,LINELEN,fp)) { 
		char *src = line + 1; // sample name treated as ix
		while (*src != '_' && *src != ' ' && *src != '\n') ++src; 
		memset(src,'\0',1); IXTYPE ix = (IXTYPE)atoll(line+1);
		if (ix > ktree->sampIX) ktree->sampIX = ix;
		
		if (!(line = fgets(line,LINELEN,fp))) // encode sequence
			{ puts("Error reading file."); return 0; }
		src = line;
		
		register size_t length = strlen(src);
		if (src[length-1] == '\n') --length; // lop off newline(s)
		if (src[length-1] == '\r') --length; // supports every platform!
		WTYPE word = *(C2Xb+*src++);
		
		// add clumps and indices to tree
		for (int k = 1; k < length; ++k) {
			word <<=2u, word +=*(C2Xb+*src++);
			if (k + 2 > PACKSIZE) KT_addWordIx(ktree, word, ix);
		}
	}
	fclose(fp); free(line); // purge buffers
	return ns-1; // number of sequences parsed
}

KTree * KT_createTree(int numThreads) {
	initConverter();
	
	// Initialize global memory manager
	KBANK = malloc(numThreads*sizeof(*KBANK));
	KBANK_BIN = calloc(numThreads,sizeof(*KBANK_BIN));
	KBANK_BINCNT = malloc(numThreads*sizeof(*KBANK_BINCNT));
	KBANK_IX = calloc(numThreads,sizeof(*KBANK_IX));
	
	// Initialize tree specific variables
	KTree *myTree = malloc(sizeof(*myTree));
	KMerX **Roots = malloc(numThreads*sizeof(*Roots));
	WTYPE *Clumps = malloc(FIRETHRES*sizeof(*Clumps));
	IXTYPE *IXs = malloc(FIRETHRES*sizeof(*IXs));
	size_t *NumsInserted = calloc(numThreads,sizeof(*NumsInserted)),
		*TotalCounts = calloc(numThreads,sizeof(*TotalCounts)),
		*BalanceThreshes = malloc(numThreads*sizeof(*BalanceThreshes));
	
	// Populate initialized variables
	for (int i = 0; i < numThreads; ++i) {
		Roots[i] = malloc(sizeof(*Roots[i]));
		*Roots[i] = (KMerX){0,0,BAD_IX,0,0};
		BalanceThreshes[i] = BAL_THRES;
		
		KBANK[i] = malloc(KBANK_INITBINS*sizeof(*KBANK[i]));
		KBANK_BINCNT[i] = KBANK_INITBINS;
		for (size_t j=0; j < KBANK_INITBINS; ++j) {
			KBANK[i][j] = malloc(KBANK_MAXK*sizeof(*KBANK[i][j])); // init this bin's kmers
			if (!KBANK[i][j]) {puts("error: xalloc 0"); exit(3); }
		}
	}
	
	// Add variables to myTree
	myTree->BalanceThreshes = BalanceThreshes;
	myTree->TotalCounts = TotalCounts;
	myTree->NumsInserted = NumsInserted;
	myTree->Clumps = Clumps;
	myTree->IXs = IXs;
	myTree->Roots = Roots;
	myTree->queuedClumps = 0;
	myTree->numThreads = numThreads;
	myTree->synced = 0;
	myTree->numInserted = 0, myTree->totalCount = 0;
	myTree->Samps = 0, myTree->sampIX = 0;
	myTree->sampStringSz = 10, myTree->SampStrings = 0;
	return myTree;
}

UTree * UT_createTree(int numThreads) {
	initConverter();
	// Initialize global memory manager
	UBANK = malloc(sizeof(*UBANK));
	UBANK_BIN = calloc(1,sizeof(*UBANK_BIN));
	UBANK_BINCNT = malloc(sizeof(*UBANK_BINCNT));
	UBANK_IX = calloc(1,sizeof(*UBANK_IX));
	UBANK[0] = malloc(UBANK_INITBINS*sizeof(*UBANK[0]));
	UBANK_BINCNT[0] = UBANK_INITBINS;
	for (size_t j=0; j < UBANK_INITBINS; ++j) {
		UBANK[0][j] = malloc(UBANK_MAXK*sizeof(*UBANK[0][j])); // init this bin's kmers
		if (!UBANK[0][j]) {puts("error: xallocY 0"); exit(3); }
	}
	
	// Initialize tree specific variables
	UTree *myTree = malloc(sizeof(*myTree));
	KMerY **Roots = malloc(KHASH_SIZE*sizeof(*Roots)); //prefix table of 8 bases
	//WTYPE *Clumps = malloc(FIRETHRES*sizeof(*Clumps));
	//IXTYPE *IXs = malloc(FIRETHRES*sizeof(*IXs));
	size_t *NumsInserted = calloc(KHASH_SIZE,sizeof(*NumsInserted)),
		*TotalCounts = calloc(KHASH_SIZE,sizeof(*TotalCounts)),
		*BalanceThreshes = malloc(KHASH_SIZE*sizeof(*BalanceThreshes));
	
	// Populate initialized tree heads
	for (unsigned i = 0; i < KHASH_SIZE; ++i) {
		Roots[i] = malloc(sizeof(*Roots[i]));
		#ifdef NO_COUNT
			*Roots[i] = (KMerY){0,EMPTY_IX,0,0};
		#else
			*Roots[i] = (KMerY){0,0,EMPTY_IX,0,0};
		#endif
		BalanceThreshes[i] = UBAL_THRES;
	}
	
	// Add variables to myTree
	myTree->BalanceThreshes = BalanceThreshes;
	myTree->NumsInserted = NumsInserted;
	myTree->TotalCounts = TotalCounts;
	myTree->Roots = Roots;
	myTree->numThreads = numThreads;
	myTree->numInserted = 0, myTree->totalCount = 0;
	myTree->Samps = 0, myTree->sampIX = 0;
	myTree->sampStringSz = 10, myTree->SampStrings = 0;
	myTree->SampCnts = 0;
	myTree->semicolons = 0;
	myTree->queuedClumps = 0;
	myTree->Pairs = malloc(FIRETHRES*sizeof(*myTree->Pairs));
	return myTree;
}

#define READ_ADD_SAMPLES() { \
	size_t ns=0, LINELEN = 10000000; \
	char *line = malloc(LINELEN + 1); line[LINELEN] = 0; \
	while (++ns, line = fgets(line,LINELEN,fp)) { \
		/* printf("%s",line); continue;  */\
		char *src = line; \
		/* *src != '_' && *src != ' ' && */ \
		while (*src != '\t') ++src; \
		memset(src,'\0',1); \
		/* printf("sampLine = %s [%llu]\n",line,(uint64_t)atol(src+1)); continue; */ \
		if (!ktree->Samps) { \
			ktree->Samps = malloc(sizeof(*ktree->Samps)); \
			/* int tab = -1; while (++tab, *(line+tab) != '\t'); \
			line[tab] = 0; */ \
			/*int len = strlen(line)+1; */ \
			char *str = malloc(src-line+1); \
			strcpy(str,line); \
			*ktree->Samps = (SampX){str,0,0,0}; \
			ktree->SampStrings = malloc(sizeof(*ktree->SampStrings)*ktree->sampStringSz); \
			ktree->SampCnts = calloc(ktree->sampStringSz,sizeof(*ktree->SampCnts)); \
			*ktree->SampStrings = str; \
			EXTRA_ADD() \
		} \
		else { \
			\
			ADD_FUNC(ktree,line); \
			EXTRA_ADD() \
			/* ktree->SampCnts[ktree->sampIX] = (CNTTYPE)atol(src+1); */ \
		} \
	} \
	free(line); \
}

#define EXTRA_ADD_NORMAL() {}
#define EXTRA_ADD_DELIM() { \
	if (ktree->sampStringSz > oldSize) \
		ktree->semicolons = realloc(ktree->semicolons, \
			sizeof(*ktree->semicolons)*ktree->sampStringSz), \
		oldSize = ktree->sampStringSz; \
	uint8_t semis = 0; \
	char *taxP = line - 1; \
	while (*++taxP) if (*taxP == delim) \
		if(*(taxP-1) != '_') ++semis; else break; \
	if (semis == 6 && *(taxP-1) != '_') ++semis; \
	ktree->semicolons[ktree->sampIX] = semis; \
}

int KT_readSamples(KTree *ktree, char *filename, char delim) {
	FILE *fp = fopen(filename,"rb"); 
	#define EXTRA_ADD EXTRA_ADD_NORMAL
	#define ADD_FUNC addSample
	READ_ADD_SAMPLES()
	fclose(fp);
	return 1;
	#undef ADD_FUNC
	#undef EXTRA_ADD
}

int readSamplesFPdelim(UTree *ktree, FILE *fp, char delim) {
	if (!fp) { puts("Invalid input file"); return 0; } 
	if (!delim) {
		#define EXTRA_ADD() EXTRA_ADD_NORMAL() \
			ktree->SampCnts[ktree->sampIX] = (uint64_t)atol(src+1);
		#define ADD_FUNC addSampleUdX
			READ_ADD_SAMPLES()
		#undef ADD_FUNC
		#undef EXTRA_ADD
		return 1;
	}
	if (!ktree->semicolons) ktree->semicolons = 
		malloc(sizeof(*ktree->semicolons)*ktree->sampStringSz);
	size_t oldSize = ktree->sampStringSz;
	#define EXTRA_ADD() EXTRA_ADD_DELIM() \
		ktree->SampCnts[ktree->sampIX] = (uint64_t)atol(src+1);
	#define ADD_FUNC addSampleUdX
		READ_ADD_SAMPLES()
	#undef EXTRA_ADD
	#undef ADD_FUNC
	return 1;
}
int UT_readSamples(UTree *ktree, char *filename, char delim) {
	FILE *fp = fopen(filename,"rb"); 
	int state = readSamplesFPdelim(ktree, fp, delim);
	fclose(fp);
	return state; 
}

int KT_writeSamples(KTree *ktree, char *filename) {
	if (!ktree->synced) KT_sync(ktree);
	FILE *of = fopen(filename,"wb");
	if (!of) { puts("Invalid output file"); return 0; }
	for (size_t i = 0; i < ktree->sampIX+1; ++i) 
		fprintf(of,"%s\n",ktree->SampStrings[i]);
	fclose(of);
	return 1;
}

int UT_writeSamples(UTree *utree, char *filename) {
	FILE *of = fopen(filename,"wb");
	if (!of) { puts("Invalid output file"); return 0; }
	for (size_t i = 0; i < utree->sampIX+1; ++i) 
		fprintf(of,"%s\t%llu\n",utree->SampStrings[i],(uint64_t)utree->SampCnts[i]);
	fclose(of);
	return 1;
}

KTree * KT_readTreeBinaryOld(char* filename, int threads) {
	FILE *fp = fopen(filename,"rb");
	if (!fp) { puts("Invalid input filename"); return 0; }
	KTree *ktree = KT_createTree(threads);
	size_t sz = lseek(fileno(fp), 0, SEEK_END); rewind(fp);
	uint64_t metadata[2] = {0};
	fread(metadata, sizeof(*metadata), 2, fp);
	
	// Check file for compatibility with this compilation config
	if (metadata[0] != sizeof(WTYPE) || metadata[1] != sizeof(IXTYPE) || 
		sizeof(CNTTYPE) != 8) {
		printf("Incompatible tree. Requires PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s\n", 
			metadata[0] << 2,"uint64_t",TYPEARR[metadata[1]]);
		return 0;
	}
	sz -= sizeof(*metadata) << 1;
	size_t numNodes = sz / sizeof(KMerX);
	if (numNodes * sizeof(KMerX) < sz) { puts("Invalid old tree."); exit(2); }
	printf("Nodes in input tree: %llu (PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s)\n",numNodes,
		metadata[0] << 2, "uint64_t", TYPEARR[metadata[1]]);
	KMerX *nodeArray = malloc(numNodes * sizeof(*nodeArray));
	fread(nodeArray, sizeof(*nodeArray), numNodes, fp);
	fclose(fp);
	
	// Make tree from node array
	size_t ix = --numNodes >> 1;
	KMerX *tree = nodeArray + ix;
	ktree->totalCount = 1;
	buildBalanceLd(tree, nodeArray, ix-1, &ktree->totalCount);
	buildBalanceRd(tree, nodeArray + (ix+1), numNodes - (ix+1),&ktree->totalCount);
	*ktree->Roots = tree;
	ktree->numInserted = numNodes + 1;
	return ktree;
}

KTree * KT_readTreeBinary(char* filename, int threads) {
	FILE *fp = fopen(filename,"rb");
	if (!fp) { puts("Invalid input filename"); return 0; }
	KTree *ktree = KT_createTree(threads);
	size_t sz = lseek(fileno(fp), 0, SEEK_END); rewind(fp);
	uint64_t metadata[3] = {0};
	fread(metadata, sizeof(*metadata), 3, fp);
	
	// Check file for compatibility with this compilation config
	if (metadata[0] != sizeof(WTYPE) || metadata[1] != sizeof(CNTTYPE) ||
		metadata[2] != sizeof(IXTYPE)) {
			printf("ERROR. Input tree requires PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s\n", 
				metadata[0] << 2,TYPEARR[metadata[1]], TYPEARR[metadata[2]]);
		return 0;
	}
	sz -= sizeof(*metadata) * 3;
	KMerX *cache = calloc(sizeof(*cache),1);
	unsigned elemSize = sizeof(cache->word) + sizeof(cache->count) + sizeof(cache->ix);
	size_t numNodes = sz / elemSize;
	printf("Nodes in input tree: %llu (PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s)\n",
		numNodes, metadata[0] << 2, TYPEARR[metadata[1]], TYPEARR[metadata[2]]);
	
	KMerX *nodeArray = malloc(numNodes * sizeof(*nodeArray));
	for (size_t i = 0; i < numNodes; ++i) {
		fread(cache, elemSize, 1, fp);
		//printf("Node %llu: word=%s, count=%llu, ix=%u\n", i, num2word(cache->word,WORDTEMP),
		//	cache->count, cache->ix);
		nodeArray[i] = *cache;
	}
	free(cache); fclose(fp);
	
	// Make tree from node array
	size_t ix = --numNodes >> 1;
	KMerX *tree = nodeArray + ix;
	ktree->totalCount = 1;
	buildBalanceLd(tree, nodeArray, ix-1, &ktree->totalCount);
	buildBalanceRd(tree, nodeArray + (ix+1), numNodes - (ix+1),&ktree->totalCount);
	*ktree->Roots = tree;
	ktree->numInserted = numNodes + 1;
	return ktree;
}

UTree * UT_readTreeBinary(char* filename, int threads, char delim) {
	FILE *fp = fopen(filename,"rb");
	if (!fp) { puts("Invalid input filename"); exit(0); }
	UTree *utree = UT_createTree(threads);
	//size_t sz = lseek64(fileno(fp), 0, SEEK_END); rewind(fp);
	uint64_t metadata[4] = {0};
	size_t numRead = fread(metadata, sizeof(*metadata), 4, fp);
	if (numRead < 4) {puts("Tree malformatted."); exit(0); }
	// Check file for compatibility with this compilation config
	#ifdef NO_COUNT
		#define CNT_SIZE 0
	#else
		#define CNT_SIZE sizeof(CNTTYPE)
	#endif
	size_t numNodes = metadata[3]; 
	if (metadata[0] != sizeof(WTYPE) || metadata[1] != CNT_SIZE ||
		metadata[2] != sizeof(IXTYPE)) {
			printf("ERROR. Input tree requires PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s\n", 
				metadata[0] << 2,TYPEARR[metadata[1]], TYPEARR[metadata[2]]);
		exit(0);
	}
	WTYPE wordCache; CNTTYPE countCache; IXTYPE ixCache;
	unsigned elemSize = sizeof(WTYPE) + CNT_SIZE + sizeof(IXTYPE);
	printf("Nodes in input tree: %llu (PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s, el=%u)\n",
		numNodes, metadata[0] << 2, TYPEARR[metadata[1]], TYPEARR[metadata[2]],elemSize);
	
	KMerY *nodeArray = malloc(numNodes * sizeof(*nodeArray));
	size_t lowbound = 0;
	fread(&wordCache,sizeof(WTYPE),1,fp);
	#ifndef NO_COUNT
	fread(&countCache,sizeof(CNTTYPE),1,fp);
	#endif
	fread(&ixCache,sizeof(IXTYPE),1,fp);
	
	static const uint64_t rshift = ((PACKSIZE << 1) - PFBITS);
	PFTYPE oldprefix = wordCache >> rshift, prefix;
	STYPE suffix = (wordCache << PFBITS) >> PFBITS;
	#ifdef NO_COUNT
		nodeArray[0] = (KMerY){suffix,ixCache,0,0};
	#else
		nodeArray[0] = (KMerY){suffix, countCache,ixCache,0,0};
	#endif
	size_t i = 1; for (; i < numNodes; ++i) {
		fread(&wordCache,sizeof(WTYPE),1,fp);
		#ifndef NO_COUNT
		fread(&countCache,sizeof(CNTTYPE),1,fp);
		#endif
		fread(&ixCache,sizeof(IXTYPE),1,fp);
		suffix = (wordCache << PFBITS) >> PFBITS;
		#ifdef NO_COUNT
			nodeArray[i] = (KMerY){suffix,ixCache,0,0};
		#else
			nodeArray[i] = (KMerY){suffix, countCache,ixCache,0,0};
		#endif

		prefix = wordCache >> rshift;
		if (prefix != oldprefix) {
			size_t numNodes = i - lowbound - 1;
			utree->NumsInserted[oldprefix] = i - lowbound;
			utree->TotalCounts[oldprefix] = 1;
			if (!numNodes) utree->Roots[oldprefix] = &nodeArray[i-1];
			else {
				size_t ix = numNodes >> 1;
				KMerY *tree = nodeArray + ix + lowbound;
				if (ix) buildBalanceLdU(tree, nodeArray + lowbound, ix-1,
					&utree->TotalCounts[oldprefix]);
				buildBalanceRdU(tree, nodeArray + (ix + 1) + lowbound,
					numNodes - (ix + 1), &utree->TotalCounts[oldprefix]);
				utree->Roots[oldprefix] = tree;
			}
			lowbound = i;
			oldprefix = prefix;
		}
	}
	//printf("lowbound? %u numNodes? %u\n",lowbound, numNodes);
	if (lowbound < numNodes) { // endcap
		numNodes = i - lowbound - 1;
		utree->NumsInserted[prefix] = i - lowbound;
		utree->TotalCounts[prefix] = 1;
		if (!numNodes) utree->Roots[prefix] = &nodeArray[i-1];
		else {
			size_t ix = numNodes >> 1;
			KMerY *tree = nodeArray + ix + lowbound;
			if (ix) buildBalanceLdU(tree, nodeArray + lowbound, ix-1,
				&utree->TotalCounts[prefix]);
			buildBalanceRdU(tree, nodeArray + (ix + 1) + lowbound,
				numNodes - (ix + 1), &utree->TotalCounts[prefix]);
			utree->Roots[prefix] = tree;
		}
	}
	// Read sample info
	int annotated = readSamplesFPdelim(utree, fp, delim);
	if (!annotated) puts("No annotation found in tree file.");
	fclose(fp);
	return utree;
}

char * bsP( char array[], size_t size, WTYPE key,const int DR_SZ);

void XT_cmp32(char *filename, char *outfile) {
	FILE *dp = fopen(filename,"rb");
	if (!dp) { puts("Invalid input filename"); exit(0); }
	uint64_t metadata[4] = {0};
	size_t numRead = fread(metadata, sizeof(*metadata), 4, dp);
	if (numRead < 4 || !metadata[3]) {puts("Tree malformatted."); exit(0); }
	// Check file for compatibility with this compilation config
	#ifdef NO_COUNT
		#define CNT_SIZE 0
	#else
		#define CNT_SIZE sizeof(CNTTYPE)
	#endif
	size_t numNodes = metadata[3]; 
	if (metadata[0] != sizeof(WTYPE) || metadata[1] != CNT_SIZE ||
		metadata[2] != sizeof(IXTYPE)) {
			printf("ERROR. Input tree requires PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s\n", 
				metadata[0] << 2,TYPEARR[metadata[1]], TYPEARR[metadata[2]]);
		exit(0);
	}
	unsigned elemSize = sizeof(WTYPE) + CNT_SIZE + sizeof(IXTYPE);
	printf("Nodes in input tree: %llu (PACKSIZE=%u, CNTTYPE=%s, IXTYPE=%s, el=%u)\n",
		numNodes, metadata[0] << 2, TYPEARR[metadata[1]], TYPEARR[metadata[2]],elemSize);
	
	static const int DR_SZ = sizeof(WTYPE) + sizeof(IXTYPE);	
	#define DR_WORD_AT(raw,i) *(WTYPE*)((raw)+DR_SZ*(i))
	#define DR_IX_AT(raw,i) *(IXTYPE*)((raw)+DR_SZ*(i)+sizeof(WTYPE))
	#define DR_ADDR_AT(raw,i) ((raw) + DR_SZ*(i))
	//SZ
	#define DR_FIRST_WORD(raw) *(WTYPE*)(raw)
	#define DR_FIRST_IX(raw) *(IXTYPE*)((raw)+sizeof(WTYPE))
	#define DR_IXDIST(raw,new) ((new)-(raw))/DR_SZ
	
	char *Dump = malloc(numNodes * DR_SZ);
	fread(Dump,DR_SZ,numNodes,dp);
	UTree *utree = calloc(1,sizeof *utree);
	utree->sampStringSz = 10;
	int annotated = readSamplesFPdelim(utree, dp, 0);
	if (!annotated) puts("No annotation found in tree file."); 
	fclose(dp);
	
	printf("Whole thing done. First word is: %s\n",KT_num2word(DR_WORD_AT(Dump,0)));
	printf("Second word is: %s\n",KT_num2word(DR_WORD_AT(Dump,1)));
	printf("Word ix 27982215 is: %s\n",KT_num2word(DR_WORD_AT(Dump,27982215))); //ATCGGAAAGAATCCCT
	WTYPE wordOfInterest = DR_WORD_AT(Dump,27982215);
	
	/* size_t foundAt;
	int bs2( char array[], size_t size, WTYPE key, size_t *index ){
		char *p=array;
		while (size) {
			size_t w=size >> 1;
			if( DR_WORD_AT(p,w+1) <= key ){ p+=(w+1)*DR_SZ; size-=w+1; } else size =w;
		}
		*index=(p-array)/DR_SZ; return DR_WORD_AT(p,0)==key;
	}
	
	printf("word of interest found? %d",bs2(Dump, numNodes-1, wordOfInterest,&foundAt));
	printf(" ...at %llu [ix=%u]\n",foundAt,DR_IX_AT(Dump,foundAt)); */
	
	// Search for word in tree
	 
	char *foundHere = bsP(Dump, numNodes-1, wordOfInterest, DR_SZ);
	printf("word of interest found with bsP? %d",foundHere);
	printf(" ...with index of %llu [ix=%u]\n",DR_IXDIST(Dump,foundHere),DR_FIRST_IX(foundHere));
	
	// build N-character (2N-bit?) bin designators
	#define DR_BITS 24
	static const int bitsLeft = PACKSIZE*2 - DR_BITS, DR_NUMBINS = (1 << DR_BITS) + 1;
	#define DR_PREFIX(x) ((x) >> bitsLeft)
	if (numNodes < UINT32_MAX) puts("Using 32-bit counters");
	uint32_t *BinIx = calloc(DR_NUMBINS,sizeof(*BinIx));
	for (size_t i = 0; i < numNodes; ++i) {
		PFTYPE v = DR_PREFIX(DR_WORD_AT(Dump,i));
		if (!BinIx[v]) BinIx[v] = i;
		//printf("prefix=%llu\n",(PFTYPE)v);
	}
	BinIx[DR_NUMBINS-1] = numNodes;
	size_t u = 0; for (; !BinIx[u]; ++u); BinIx[u] = 0;
	for (size_t i = DR_NUMBINS-2; i > u; --i) if (!BinIx[i]) BinIx[i] = BinIx[i+1];
	
	// Search for test word in bin range
	WTYPE qprefix = DR_PREFIX(wordOfInterest);
	size_t start_i = BinIx[qprefix], end_i = BinIx[qprefix+1];
	if (start_i == end_i) puts("This aint gonna work."); 
	else {
		char *found = bsP(DR_ADDR_AT(Dump,start_i), end_i-start_i-1, wordOfInterest, DR_SZ);
		printf("Found? %d At: %llu of taxon: %u \n",found, DR_IXDIST(Dump, found), DR_FIRST_IX(found));
	}
	
	// Compress and store the tree
	int cmpStr = 3; // curSz; //2
	char *cmask = malloc(sizeof(WTYPE)); // round up to whole word size of WTYPE
	int curSz = sizeof(WTYPE), cmpSz = sizeof(WTYPE) - cmpStr; //= sizeof(Darkness);
	for (int i = 0; i < cmpSz; ++i) cmask[i] = 0xff;
	for (int i = cmpSz; i < curSz; ++i) cmask[i] = 0x00;
	WTYPE mask = *(WTYPE*)cmask;
	FILE *prefixPtrs = fopen(outfile,"wb");
	if (!prefixPtrs) { puts("Invalid output filename"); exit(0); }
	
	//metadata[1] = 2; // bytes for prefix (2 * bits = 16 bits)
	fwrite(metadata,sizeof *metadata,4,prefixPtrs);
	fwrite(BinIx,sizeof *BinIx, DR_NUMBINS, prefixPtrs);
	for (size_t i = 0; i < numNodes; ++i) {
		fwrite(DR_ADDR_AT(Dump,i),1,cmpSz,prefixPtrs);
		fwrite(DR_ADDR_AT(Dump,i)+sizeof(WTYPE),sizeof(IXTYPE),1,prefixPtrs);
	}
	uint64_t total = 0;
	for (size_t i = 0; i < utree->sampIX+1; ++i) 
		total += utree->SampCnts[i], 
		fprintf(prefixPtrs,"%s\t%llu\n",utree->SampStrings[i],(uint64_t)utree->SampCnts[i]);
	printf("Total nodes in tree: %llu [%llu labels]\n",total,(uint64_t)utree->sampIX+1);
}
char * bsP( char array[], size_t size, WTYPE key, const int DR_SZ) {
	char *p=array;
	while (size) {
		size_t w = size >> 1;
		if (DR_WORD_AT(p,w+1) <= key) p+=(w+1)*DR_SZ, size-=w+1; 
		else size =w;
	}
	return *(WTYPE*)p==key ? p : 0;
}


int KT_writeTreeBinary(KTree *ktree, char* filename) {
	if (!ktree->synced) KT_sync(ktree);
	FILE *of = fopen(filename,"wb");
	if (!of) { puts("Invalid output filename"); return 0; }
	uint64_t metadata[3] = {sizeof(WTYPE), sizeof(CNTTYPE), sizeof(IXTYPE)};
	fwrite(metadata,sizeof(uint64_t),3,of);
	traceTreeB(*ktree->Roots, of);
	fclose(of);
	return 1;
}
int UT_writeTreeBinary(UTree *utree, char* filename) {
	FILE *of = fopen(filename,"wb");
	if (!of) { puts("Invalid output filename"); return 0; }
	#ifdef NO_COUNT
		#define CNT_SIZE 0
	#else
		#define CNT_SIZE sizeof(CNTTYPE)
	#endif
	uint64_t metadata[4] = {sizeof(WTYPE), CNT_SIZE, sizeof(IXTYPE),0};
	fwrite(metadata,sizeof(*metadata),4,of);
	if (!utree->SampCnts) {
		utree->SampCnts = calloc(utree->sampIX + 1,sizeof(*utree->SampCnts));
		for (size_t i = 0; i < KHASH_SIZE; ++i) {
			traceTreeBUf(i,utree->Roots[i], utree->SampCnts, of);
		}
	}
	else { //for (size_t i = 0; i < utree->sampIX + 1; ++i) printf("%s [%llu]\n",utree->SampStrings[i],utree->SampCnts[i]);
		for (size_t i = 0; i < KHASH_SIZE; ++i) {
			traceTreeBU(i,utree->Roots[i], of);
		}
	}
	// Embed sample info into tree
	uint64_t total = 0;
	for (size_t i = 0; i < utree->sampIX+1; ++i) 
		total += utree->SampCnts[i], 
		fprintf(of,"%s\t%llu\n",utree->SampStrings[i],(uint64_t)utree->SampCnts[i]);
	printf("Total nodes in tree: %llu [%llu labels]\n",total,(uint64_t)utree->sampIX+1);
	//metadata[3] = total;
	//rewind(fp); 
	fseek(of,3*sizeof(uint64_t),SEEK_SET);
	fwrite(&total,sizeof(total),1,of);
	fclose(of);
	return 1;
}
int KT_writeTreeBinaryFull(KTree *ktree, char* filename) {
	if (!ktree->synced) KT_sync(ktree);
	FILE *of = fopen(filename,"wb");
	if (!of) { puts("Invalid output filename"); return 0; }
	uint64_t metadata[3] = {sizeof(WTYPE), sizeof(CNTTYPE), sizeof(IXTYPE)};
	fwrite(metadata,sizeof(uint64_t),3,of);
	traceTreeBF(*ktree->Roots, of);
	fclose(of);
	return 1;
}

int KT_writeTreeTxt(KTree *ktree, char* filename) {
	if (!ktree->synced) KT_sync(ktree);
	FILE *of = fopen(filename,"wb");
	if (!of) { puts("Invalid output tree"); return 0; }
	traceTree(*ktree->Roots, of);
	fclose(of);
	return 1;
}

int KT_writeFullTreeTxt(KTree *ktree, char* filename) {
	if (!ktree->synced) KT_sync(ktree);
	FILE *of = fopen(filename,"wb");
	if (!of) { puts("Invalid output tree"); return 0; }
	traceTreeF(*ktree->Roots, of);
	fclose(of);
	return 1;
}

// usage: RadixalTriecrobium inSeqs.fna [threads]
int main(int argc, char *argv[]) { // for testing
	//printf("Size of KMerX = %u\n",sizeof(KMerX)); // return 0;
	//printf("KMerX size=%u, KMerY size=%u\n",sizeof(KMerX),sizeof(KMerY)); return;
	//UT_parseSampFastaExtern(UTree *utree, char* filename, char* labels);
	/* const int IXIX = sizeof(WTYPE) / sizeof(IXTYPE);
	const int SZ = sizeof(WTYPE) + sizeof(IXTYPE);
	const int SZ3 = SZ*3;
	typedef union {
		//WTYPE word;
		char a[SZ];
		//IXTYPE ix[IXIX];
	} BinRecord;
	char W[18] = "AAAAAABBBBBBCCCCC\0"; //= {0};
	printf("sizeof BinRecord: %u [IXIX=%d], w: %u\n",sizeof(BinRecord),IXIX,sizeof(W)); 
	printf("W is: %s\n",W);
	WTYPE *W_word = (WTYPE *)W;
	//CNTTYPE *W_cnt = W + sizeof(WTYPE);
	IXTYPE *W_ix = (IXTYPE *)(W + sizeof(WTYPE));
	*W_word = KT_word2num("ACTGCCAGACCTTCAG\0");
	printf("W is: %s\n",W);
	*W_ix = 404;
	printf("W is: %s\n",W); */
	#ifdef COMPRESS
	if (argc != 3) {puts("usage: xtree-compress preTree.cbt, compTree.ctr"); exit(1); }
	XT_cmp32(argv[1],argv[2]); //("outNEW.cbt","compTre.ctr");
	exit(0);
	#endif
	#ifdef SEARCH
	if (argc != 3) {puts("usage: xtree-search compTree.ctr fastaToSearch.fa"); exit(1); }
	UTree *xtr = XT_read32(argv[1]); //("compTre.ctr");
	XT_doSearch32(xtr,argv[2],"results.txt",0);
	exit(0);
	#endif
	#ifdef BUILD
	if (argc < 2) {puts("usage: utree-build input_fasta.fa threads labelmap.db"); exit(1); }

	int threads = 1;
	#ifdef _OPENMP
		threads = omp_get_max_threads();
		if (argc > 2) threads = atoi(argv[2]);
		omp_set_num_threads(threads);
	#endif
	
	char *filename = "seqs.fna\0";
	if (argc > 1) filename = argv[1];
	printf("Running with %d threads...\n",threads);
	//goto ReadIn;
	UTree *myU = UT_createTree(threads);
		
	//UT_parseSampFastaExtern(myU,filename,"db/99_otu_taxonomy.txt",1);
	char *dbname = "db/img_taxonomy.txt";
	if (argc > 3) dbname = argv[3];
	UT_parseSampFastaExternOSFA(myU,filename,dbname,0,1,PACKSIZE/2,0); // 0,2 for ixcol, ixlab in img
	//UT_parseSampFastaGG(myU,filename,dbname,1);
	//UT_parseSampFastaExternOSFA(myU,filename,dbname,0,1,2,1);
	
	//UT_parseSampFastaQIIME(myU,filename,"94_otu_taxonomy.txt");
	//UT_parseSampFasta(myU,filename);
	//UT_parseSampFastaSparse(myU,filename,1,1); // arg 1 = sparsity. 0 = super fast, 1 and up is decreasing stringency, arg 2 = whether to resparsify
	//UT_parseSampFasta(myU,filename);
	UT_writeTreeBinary(myU, "outNEW.cbt");
	
	//if (!myU->SampCnts) 
	//	myU->SampCnts = calloc(myU->sampIX + 1,sizeof(*myU->SampCnts));
	
	UT_writeSamples(myU, "sampNEW.txt");
	return 0;
	#endif
	puts("Nothing to see here. Compile with -D BUILD, SEARCH, or COMPRESS");
	exit(-1);
TestTree:
	puts("Reading tree...");
	UTree *newU = UT_readTreeBinary("outNEW.cbt",threads,0);
	//UT_writeTreeBinary(newU, "newU.cbt");
	//UT_writeSamples(newU, "samp.txt");

	//UT_readSamples(newU,"sampNEW.txt");
	//UT_readSamplesDelim(newU,"sampNEW.txt",';');
	//exit(1);
	//UT_writeTreeBinary(newU, "newU.cbt");
	//UT_writeSamples(newU, "samsU.txt");
	//exit(3);
	printf("Searching for test k-mers...\n");
	//UT_searchQueries(newU,filename,"taxonomy_assigned.txt",7);
	UT_searchQueries(newU,filename,"taxonomy_assigned.txt",0);
	return 0;
	
	// First, create a tree with some amount of threads
	KTree *myTree = KT_createTree(threads);
	puts("Parsing input file.");
	//KT_parseSampFasta(myTree, filename); // and parse in your file
	//KT_sync(myTree);
	//KT_simpleBalancePurge(myTree);
	KT_parseSampFastaSparse(myTree, filename, 1); // last arg is speed. 1-inf, or 0.
	
	// Export the tree (if you want to load it in later):
	puts("Exporting binary tree.");
	//KT_writeTreeBinary(myTree, "savedTree.btr");
	KT_writeTreeBinary(myTree, "savedTree.ctr");
	//KT_writeTreeBinaryFull(myTree,"savedTreeF.ctr");
	return 0;
	// Or if you want to actually browse at the tree's sorted contents
	//puts("Exporting text tree.");
	//KT_writeTreeTxt(myTree, "savedTree_text.txt");
	//KT_writeFullTreeTxt(myTree, "savedTree_fulltext.txt");
	
	// Also export the generated samples/species in the order they were indexed:
	puts("Exporting index list.");
	KT_writeSamples(myTree, "savedSamps.txt");

	puts("Done with database creation."); return 0;

ReadIn:
	// ...some other time you can read them back in:
	puts("Importing exported tree.");
	//KTree *myNewerTree = KT_readTreeBinary("savedTree.btr", threads);
	KTree *myNewerTree = KT_readTreeBinary("savedTree.ctr", threads);
	
	//puts("Exporting imported tree to text.");
	KT_writeTreeTxt(myNewerTree,"outtxtTree.txt");
	//KT_writeTreeTxt(myTree,"outtxtTree-old.txt");
	//KT_writeFullTreeTxt(myTree,"fullTree.txt");
	return 0;
	
	puts("Reading in samples.");
	KT_readSamples(myNewerTree, "savedSamps.txt",0);

	// And then perform whatever querying you like:
	puts("Querying database for test K-mer.");
	char kmer[33] = "AAAAACCAGGGCTTAACTCTGGGACTGCTTTT\0"; //"AGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCT\0";
	size_t count;
	IXTYPE myIX = KT_findIxCount(myNewerTree, KT_word2num(kmer), &count);
	if (myIX != BAD_IX) 
		printf("K-mer found at IX=%llu [Sample %s] %llu times!\n",myIX,
			myNewerTree->SampStrings[myIX],count);
	else 
		printf("K-mer not found.\n");
	return 0;
}